" vim: set foldmethod=marker foldlevel=0 nomodeline:

" =======================================================================================
" PLUGINS {{{
" =======================================================================================


" vim-plugin
" ---------------------------------------------------------------------------------------
  let data_dir = has('nvim') ? stdpath('data') . '/site' : '~/.vim'
  if empty(glob(data_dir . '/autoload/plug.vim'))
    silent execute '!curl -fLo '.data_dir.'/autoload/plug.vim --create-dirs https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim'
    autocmd VimEnter * PlugInstall --sync | source $MYVIMRC
  endif

  call plug#begin(has('nvim') ? stdpath('data') . '/plugged' : '~/.vim/plugged')


" Themes
" ---------------------------------------------------------------------------------------
  if has("nvim-0.7")
    Plug 'nvim-tree/nvim-web-devicons'
  else
    Plug 'ryanoasis/vim-devicons'
  endif

  Plug 'morhetz/gruvbox'
  Plug 'w0ng/vim-hybrid'
  Plug 'joshdick/onedark.vim'
  Plug 'dracula/vim', { 'as': 'dracula' }
  Plug 'sainnhe/edge'
  if has('nvim')
    Plug 'rose-pine/neovim', { 'as': 'rose-pine' }
    Plug 'catppuccin/nvim', { 'as': 'catppuccin' }
    Plug 'vague2k/vague.nvim'
  endif


" Convenient
" ---------------------------------------------------------------------------------------
  Plug 'scrooloose/nerdcommenter'
  Plug 'christoomey/vim-tmux-navigator'
  Plug 'junegunn/vim-easy-align', { 'on': '<Plug>(EasyAlign)' }
  Plug 'junegunn/gv.vim', { 'on': [ 'GV', 'GV!' ] }
  Plug 'junegunn/vim-peekaboo'
  Plug 'junegunn/fzf', { 'do': { -> fzf#install() } }
  Plug 'junegunn/fzf.vim'
  Plug 'unblevable/quick-scope'
  Plug 'tpope/vim-fugitive'
  Plug 'tpope/vim-rhubarb'
  Plug 'tpope/vim-repeat'
  Plug 'tpope/vim-surround'
  Plug 'tpope/vim-unimpaired'
  " Plug 'tpope/vim-obsession'
  Plug 'tpope/vim-abolish'
  Plug 'tpope/vim-dispatch'
  Plug 'tpope/vim-endwise'
  Plug 'tpope/vim-vinegar'
  Plug 'rrethy/vim-hexokinase', { 'do': 'make hexokinase' }
  Plug 'chrisbra/csv.vim', { 'for': 'csv' }

  if has("nvim-0.5")
    Plug 'nvim-lua/plenary.nvim'
    Plug 'lewis6991/gitsigns.nvim'
  else
    Plug 'mhinz/vim-signify'
  endif

  if has('nvim-0.4.0') && exists('*nvim_open_win')
    Plug 'rhysd/git-messenger.vim'
  endif

  if has("nvim-0.5")
    Plug 'lukas-reineke/indent-blankline.nvim'
  else
    Plug 'Yggdroot/indentLine'
  endif

  if has("nvim-0.5")
    " TODO: change branch if main branch is stable
    Plug 'nvim-treesitter/nvim-treesitter', { 'branch': 'master', 'do': ':TSUpdate' }
    Plug 'nvim-treesitter/nvim-treesitter-context'
  elseif has('nvim')
    Plug 'numirias/semshi', { 'do': ':UpdateRemotePlugins', 'for': 'python' }
  endif

  " Plug 'LunarWatcher/auto-pairs'
  Plug 'AndrewRadev/splitjoin.vim'
  Plug 'liuchengxu/vista.vim'
  Plug 'kkoomen/vim-doge', { 'do': { -> doge#install() } }


" Language Specific
" ---------------------------------------------------------------------------------------
  " Plug 'SirVer/ultisnips'

  if has("nvim-0.7")
    Plug 'williamboman/mason.nvim', { 'do': ':MasonUpdate' }
    Plug 'williamboman/mason-lspconfig.nvim'
    Plug 'jay-babu/mason-null-ls.nvim'
    Plug 'neovim/nvim-lspconfig'
    Plug 'nvim-lua/lsp-status.nvim'
    Plug 'nvimtools/none-ls.nvim'
    Plug 'stevearc/conform.nvim'

    Plug 'hrsh7th/nvim-cmp'
    Plug 'hrsh7th/cmp-nvim-lsp'
    Plug 'hrsh7th/cmp-buffer'
    Plug 'hrsh7th/cmp-path'
    Plug 'hrsh7th/cmp-emoji'
    Plug 'hrsh7th/cmp-cmdline'
    Plug 'andersevenrud/cmp-tmux'
    Plug 'L3MON4D3/LuaSnip'
    Plug 'saadparwaiz1/cmp_luasnip'

    Plug 'ray-x/lsp_signature.nvim'
    " Plug 'hood/popui.nvim'
    " Plug 'quangnguyen30192/cmp-nvim-ultisnips'
    Plug 'windwp/nvim-ts-autotag'
    Plug 'dmmulroy/ts-error-translator.nvim'
    Plug 'diogo464/kubernetes.nvim'
  else
    Plug 'neoclide/coc.nvim', { 'branch': 'release' }
    Plug 'dag/vim-fish', { 'for': 'fish' }
    Plug 'lervag/vimtex', { 'for': 'tex' }
    Plug 'fatih/vim-go', { 'do': ':GoUpdateBinaries', 'for': 'go' }
    Plug 'wellle/tmux-complete.vim'
  endif
    " Plug 'rafamadriz/friendly-snippets'
  Plug 'honza/vim-snippets'
  " Plug 'Vimjas/vim-python-pep8-indent', { 'for': 'python' }
  Plug 'pearofducks/ansible-vim'
  Plug 'plasticboy/vim-markdown', { 'for': 'markdown' }    " no treesitter parser
  Plug 'mzlogin/vim-markdown-toc', { 'for': 'markdown' }
  if has('nvim') || v:version >= 800
    Plug 'iamcco/markdown-preview.nvim',
          \ { 'do': ':call mkdp#util#install()', 'for': 'markdown', 'on': 'MarkdownPreview' }
  endif

  if has("nvim-0.8.0")
    Plug 'mfussenegger/nvim-dap'
    Plug 'nvim-neotest/nvim-nio'
    Plug 'rcarriga/nvim-dap-ui'
  endif
  if has("nvim-0.9")
    Plug 'andrewferrier/debugprint.nvim'
  endif


" Etc.
" ---------------------------------------------------------------------------------------
  Plug 'mhinz/vim-startify'
  if has("nvim-0.5")
    Plug 'folke/which-key.nvim'
  else
    Plug 'liuchengxu/vim-which-key', { 'on': ['WhichKey', 'WhichKey!'] }
  endif


" Initialize plugin system
" ---------------------------------------------------------------------------------------
  call plug#end()



" }}}
" =======================================================================================
" BASIC SETTING {{{
" =======================================================================================

" General
" --------------------------------------------------------------------------------------
  filetype plugin indent on             " Enable filetype plugins
  syntax enable                         " enable syntax processing
  set autoread                          " auto read when a file is changed from the outside

  set nocompatible                      " do not compatible to original vi
  set wrap
  set nowrapscan                        " do not go back to the first of the line when it reaches at the end of the line
  set nobackup                          " do not create backup file
  set noswapfile                        " do not create swap file
  set visualbell                        " visualbell on
  set fencs=ucs-bom,utf-8,euc-kr.latin1 " hangle goes euc-kr, unicode goes unicode
  set fileencoding=utf-8                " file saving encoding
  if exists('+termencoding')
    set tenc=utf-8                      " terminal encoding
  endif
  set backspace=eol,start,indent        " go to earlier line where the cursor is positioned at end of the line, start of the line and indent
  set hidden                            " unsaved changes in buffer is hidden not quit
  set history=1000                      " remember more commands and search history
  set undofile                          " Maintain undo history between sessions
  set undolevels=1000                   " use many muchos levels of undo
  if has('nvim')
    set undodir=~/.config/nvim/undodir
  else
    set undodir=~/.vim/undodir
  endif
  set laststatus=2                      " status bar is always on
  set showtabline=2                     " tab bar is always on
  set signcolumn=yes                    " always draw the sign column
  set linebreak
  set colorcolumn=90                    " color column to limit coding length
  if exists('+pastetoggle')
    set pastetoggle=<F2>                " when in insert mode, press <F2> to go to
                                        " pasete mode, where you can paste mass data
                                        " that won't be autoindent
  endif
  set scrolloff=5                       " When scrolling, keep cursor 5 lines away from screen border
  set cmdheight=2                       " Give more space for displaying messages.
  set updatetime=300                    " Having longer updatetime (default is 4000 ms = 4 s) leads to noticeable
                                        " delays and poor user experience.
  set shortmess+=c                      " Don't pass messages to ins-completion-menu.
  set mouse=                            " Disable mouse support

  " " Recently vim can merge signcolumn and number column into one
  " if has("patch-8.1.1564")
  "   " set signcolumn=number
  " endif

  set list                                                    " show unvisible characters
  set listchars=tab:Â»\ ,nbsp:â£,trail:Â·,extends:>,precedes:<   " set unvisible characters
  set showbreak=â†ª\                                            " set breakindent

  " visual autocomplete for command menu
  set wildmenu
  set wildmode=full
  " set wildmode=list:longest,full
  " Setting up ignores
  set wildignore+=*/tmp/*,*.so,*.pyc,*.png,*.jpg,*.gif,*.jpeg,*.ico,*.pdf
  set wildignore+=*.wav,*.mp4,*.mp3
  set wildignore+=*.o,*.out,*.obj,.git,*.rbc,*.rbo,*.class,.svn,*.gem
  set wildignore+=*.zip,*.tar.gz,*.tar.bz2,*.rar,*.tar.xz
  set wildignore+=*/vendor/gems/*,*/vendor/cache/*,*/.bundle/*,*/.sass-cache/*
  set wildignore+=*.swp,*~,._*
  set wildignore+=_pycache_,.DS_Store,.vscode,.localized

  " Resize panes whenever containing window resized.
  augroup resize_window
    autocmd!
    autocmd VimResized * wincmd =
  augroup END

  " diff: ignore whitespaces
  " https://www.micahsmith.com/blog/2019/11/fixing-vim-invalid-argument-diffopt-iwhite/
  if ! has('nvim')
    set diffopt-=internal
    set diffopt+=iwhite
  endif

  " only higlight the first 500 characters of each line to improve
  " performance for long line
  " set synmaxcol=500

  " Change grep to rg if it exists
  if executable('rg')
    set grepprg=rg\ --smart-case\ --vimgrep\ --no-heading
  endif



" Colorscheme
" ---------------------------------------------------------------------------------------

  " Terminal.app does not support truecolor
  if (has("termguicolors"))
    " set Vim-specific sequences for RGB colors
    let &t_8b = "\<Esc>[48;2;%lu;%lu;%lum"
    let &t_8f = "\<Esc>[38;2;%lu;%lu;%lum"
    set termguicolors
  endif

  set t_Co=256            " enable 256 color terminal


  " ChangeBackground changes theme and background
  function! ChangeBackground(...)

    " default background
    let l:background = "dark"

    " Change background
    if !empty($TMUX)
      if system('tmux show-env BG_LUMINANCE') !~# '^-.*'
        if split(trim(system('tmux show-env BG_LUMINANCE')), '=')[1] == "light"
          let l:background = "light"
        else
          let l:background = "dark"
        endif
      endif
    else
      if exists('$BG_LUMINANCE') && $BG_LUMINANCE == 'light'
          let l:background = "light"
      else
          let l:background = "dark"
      endif
    endif

    execute "set background=" . l:background

    " Change colorscheme
    try
      if a:0 > 0
        execute 'colorscheme ' . a:1
      else
        if !empty($TMUX)
          if system('tmux show-env COLOUR_SCHEME') !~# '^-.*'
            let l:scheme = split(trim(system('tmux show-env COLOUR_SCHEME')), '=')[1]
          endif
        else
          if exists('$COLOUR_SCHEME')
            let l:scheme = $COLOUR_SCHEME
          endif
        endif

        if l:scheme =~ 'rose-pine.*'
          let g:rose_pine_variant = split(l:scheme, "-")[-1]
          let l:scheme = 'rose-pine'
          lua << EOF
require("rose-pine").setup({
  dark_variant = vim.g.rose_pine_variant,
  dim_inactive_windows = false,
  highlight_groups = {
    StatusLine = { fg = "love", bg = "love", blend = 10 },
    CurSearch = { fg = "base", bg = "leaf", inherit = false },
    Search = { fg = "text", bg = "leaf", blend = 20, inherit = false },
    QuickFixLine = { link = "Question" },
  }
})
EOF
          unlet g:rose_pine_variant
        endif

        execute 'colorscheme ' . l:scheme
      endif
    catch
      colorscheme seoul256
    endtry

  endfunction

  call ChangeBackground()


" Spaces & Tabs
" ---------------------------------------------------------------------------------------
  set tabstop=2       " number of visual spaces per TAB
  set softtabstop=2   " number of spaces in tab when editing
  set expandtab       " tabs are spaces
  set shiftwidth=2    " auto indent 2
  set cindent         " indent only for C language
  set smartindent     " smart indentation
  set copyindent      " copy the previous indentation on autoindenting
  set autoindent      " always set autoindenting on
  " autocmd FileType yaml setlocal tabstop=2 softtabstop=2 shiftwidth=2


" UI Config
" ---------------------------------------------------------------------------------------
  set ruler           " show line and col
  set relativenumber  " show relative line numbers
  set number          " show absolute line numbers where your cursor is
  set numberwidth=3   " keep the line number gutter narrow
  set showcmd         " show command in bottom bar
  set cursorline      " highlight current line
  set showmatch       " highlight matching [{()}]
  set title           " change the terminal's title
  set lazyredraw      " redraw only when we need to
  set noshowmode      " for echodoc to hide -- INSERT -- in command line


" Searching
" ---------------------------------------------------------------------------------------
  set incsearch       " show search matches as you type
  set hlsearch        " highlight mtches
  set ignorecase      " ignore case when searching
  set smartcase       " ignore case if search pattern is all lowercase,
                      " case-sensitive otherwise

" Folding
" ---------------------------------------------------------------------------------------
  set foldenable          " enable folding
  set foldlevelstart=10   " open most folds by default
  set foldnestmax=10      " 10 nested fold max
  set foldmethod=manual   " fold manually
  set foldlevel=1
  set foldtext=           " do not change fold text


" StatusLine
" ---------------------------------------------------------------------------------------

  if has("nvim-0.5")
    lua require("config.statusline")
  else
    function! StatusLineActive()
      let ft  = "%{len(&filetype) ? '['.&filetype.'] ' : ''}"
      let mod = "%{&modified ? 'ðŸ–‹ï¸' : !&modifiable ? 'ðŸ”’' : ''}"
      let ro  = "%{&readonly ? 'ðŸ‘€' : ''}"
      let fug = "%{exists('g:loaded_fugitive') ? fugitive#statusline() : ''}"
      let sep = ' %= '
      let pos = ' %-12(%l : %c%V%) '
      let format = ' %-7([%{&fileformat}]%) '
      let pct = ' %P'
      return '[%n] ðŸŒ¸ %f '.ft.mod.' '.ro.' %<'.sep.fug.format.pos.'%*'.pct
    endfunction
    function! StatusLineInactive()
      return '[%n] %F'
    endfunction
    augroup statusline
      autocmd!
      autocmd WinEnter,BufEnter * setlocal statusline=%!StatusLineActive()
      autocmd WinLeave,BufLeave * setlocal statusline=%!StatusLineInactive()
    augroup end
  endif



" }}}
" =======================================================================================
" MAPPINGS {{{
" =======================================================================================


" leader is now comma
" ---------------------------------------------------------------------------------------
  map , <leader>


" work like * and g*, but do not move the cursor and always set hls
" ---------------------------------------------------------------------------------------
  nnoremap * :let @/ = '\<'.expand('<cword>').'\>'\|set hlsearch<C-M>
  nnoremap g* :let @/ = expand('<cword>')\|set hlsearch<C-M>


" visual mode pressing * or # searches for the current selection
" ---------------------------------------------------------------------------------------
  vnoremap <silent> * :<C-U>
        \let old_reg=getreg('"')<Bar>let old_regtype=getregtype('"')<CR>
        \gvy/<C-R>=&ic?'\c':'\C'<CR><C-R><C-R>=substitute(
        \escape(@", '/\.*$^~['), '\_s\+', '\\_s\\+', 'g')<CR><CR>
        \gVzv:call setreg('"', old_reg, old_regtype)<CR>
  vnoremap <silent> # :<C-U>
        \let old_reg=getreg('"')<Bar>let old_regtype=getregtype('"')<CR>
        \gvy?<C-R>=&ic?'\c':'\C'<CR><C-R><C-R>=substitute(
        \escape(@", '?\.*$^~['), '\_s\+', '\\_s\\+', 'g')<CR><CR>
        \gVzv:call setreg('"', old_reg, old_regtype)<CR>

" do not exit from visual mode when shifting
" ---------------------------------------------------------------------------------------
  vnoremap < <gv
  vnoremap > >gv


" Treat long lines as break lines
" (useful when moving around in them) but when preceded by a count,
" go back to normal and save movement in jumplist lager than 5
" ---------------------------------------------------------------------------------------
  nnoremap <expr> j v:count ? (v:count > 5 ? "m'" . v:count : '') . 'j' : 'gj'
  nnoremap <expr> k v:count ? (v:count > 5 ? "m'" . v:count : '') . 'k' : 'gk'


" turn off search highlight
" ---------------------------------------------------------------------------------------
  nmap <leader><space> :nohlsearch<CR>


" Make arrow keys do something useful
" ---------------------------------------------------------------------------------------
  nnoremap <Left> :vertical resize +2<CR>
  nnoremap <Right> :vertical resize -2<CR>
  nnoremap <Up> :resize -2<CR>
  nnoremap <Down> :resize +2<CR><Paste>


" Buffer navigation
" ---------------------------------------------------------------------------------------
  function! s:buffernavigation(cmd)
    let buf = bufnr()
    execute a:cmd
    while ( &buftype == 'terminal'
          \ || &filetype == 'qf'
          \ || &filetype == 'fugitive'
          \ || &filetype == 'netrw'
          \ || &filetype == 'dirvish')
          \ && bufnr() != buf
      execute a:cmd
    endwhile
  endfunction

  " buffer previous
  nnoremap [b :<c-u>call <SID>buffernavigation('bprevious')<CR>
  " buffer next
  nnoremap ]b :<c-u>call <SID>buffernavigation('bnext')<CR>
  " new empty buffer
  nnoremap <C-b> :enew<CR>
  " conform changes (Yes, No, Cancel) instead of error
  " set confirm
  " close buffer
  nnoremap <leader>bx :bp <BAR> bd #<CR>


" Tab navigations
" ---------------------------------------------------------------------------------------
  " tap previous
  nnoremap [t  :tabprevious<CR>
  " tap next
  nnoremap ]t  :tabnext<CR>
  function! OpenCurrentAsNewTab()
    let l:currentPos = getcurpos()
    tabedit %
    call setpos(".", l:currentPos)
  endfunction
  " new tap with current buffer
  nnoremap <C-t> :call OpenCurrentAsNewTab()<CR>
  " close tap
  nnoremap <leader>tx :tabclose<CR>


" Window navigations
" ---------------------------------------------------------------------------------------
  nmap <C-J> <C-W><C-J>
  nmap <C-K> <C-W><C-K>
  nmap <C-L> <C-W><C-L>
  nmap <C-H> <C-W><C-H>
  set splitbelow
  set splitright

  " remove window
  nmap <C-W>x <C-W>q

  " circular navigation
  " nnoremap <tab>   <c-w>w
  " nnoremap <S-tab> <c-w>W


" argument list
" ---------------------------------------------------------------------------------------
  " arglist previous with visual feedback
  nnoremap [a <cmd>exe v:count1 .. 'N'<bar>args<cr><esc>
  " arglist next with visual feedback
  nnoremap ]a <cmd>exe v:count1 .. 'n'<bar>args<cr><esc>
  " add current buffer to arglist and and deduplicate it
  nnoremap <leader>aa <cmd>$arge %<bar>argded<bar>args<cr>
  " local arglist per tab
  augroup local_arglist
    autocmd!
    autocmd TabNewEntered * argl|%argd
  augroup END


" yanked text using osc52 and X11
" ---------------------------------------------------------------------------------------
  " copy to attached terminal using the yank(1) script:
  " https://github.com/sunaku/home/blob/master/bin/yank
  function! s:yank(text) abort
    " if in tmux, update environment variable to yank properly
    if !empty($TMUX)
      " if SSH_TTY is set
      if system('tmux show-env SSH_TTY') !~# '^-.*'
        let $SSH_TTY = split(trim(system('tmux show-env SSH_TTY')), '=')[1]
      endif
      " if DISPLAY is set
      if system('tmux show-env DISPLAY') !~# '^-.*'
        let $DISPLAY = split(trim(system('tmux show-env DISPLAY')), '=')[1]
      endif
    endif
    " try osc52 first
    if executable('osc52')
      let escape = system('osc52', a:text)
      if v:shell_error
        echoerr escape
        echo 'Using X11 to copy'
        call setreg('+', a:text)
      endif
    else
      call setreg('+', a:text)
    endif
  endfunction

  function! s:get_from_marker(m_start, m_end)
    " Why is this not a built-in Vim script function?!
    let [line_start, column_start] = getpos(a:m_start)[1:2]
    let [line_end, column_end] = getpos(a:m_end)[1:2]
    let lines = getline(line_start, line_end)
    if len(lines) == 0
      return ''
    endif
    let lines[-1] = lines[-1][: column_end - (&selection == 'inclusive' ? 1 : 2)]
    let lines[0] = lines[0][column_start - 1:]
    return join(lines, "\n")
  endfunction

  function! s:yank_wrapper(type, ...)
    let sel_save = &selection
    let &selection = "inclusive"
    let reg_save = @@

    if a:0  " Invoked from Visual mode
      call s:yank(s:get_from_marker("'<", "'>'"))
    elseif a:type == 'line'
      call s:yank(s:get_from_marker("'[", "']'"))
    else
      call s:yank(s:get_from_marker("`[", "`]'"))
    endif

    let &selection = sel_save
    let @@ = reg_save
  endfunction

  nmap <silent> <leader>y :set opfunc=<SID>yank_wrapper<CR>g@
  vmap <silent> <leader>y :<C-U>call <SID>yank_wrapper(visualmode(), 1)<CR>


" Terminal inside of vim
" steal from https://github.com/vimlab/split-term.vim
" ---------------------------------------------------------------------------------------
  function! s:openBuffer(count, vertical)
    let cmd = a:vertical ? 'vnew' : 'new'
    let cmd = a:count ? a:count . cmd : cmd
    exe cmd
  endfunction
  " steal https://github.com/junegunn/fzf.vim/issues/821#issuecomment-581273191
  function! s:openFloatBuffer()
    " Configuration
    let height = float2nr((&lines - 2) * 0.6)
    let row = float2nr((&lines - height) / 2)
    let width = float2nr(&columns * 0.8)
    let col = float2nr((&columns - width) / 2)
    let top = "â•­" . repeat("â”€", width + 2) . "â•®"
    let mid = "â”‚" . repeat(" ", width + 2) . "â”‚"
    let bot = "â•°" . repeat("â”€", width + 2) . "â•¯"
    let border = [top] + repeat([mid], height) + [bot]

    " Border Window
    let border_opts = {
          \ 'row': row - 1,
          \ 'col': col - 2,
          \ 'width': width + 4,
          \ 'height': height + 2,
          \ }
    " Terminal Window
    let opts = {
          \ 'row': row,
          \ 'col': col,
          \ 'width': width,
          \ 'height': height,
          \ }

    if has ('nvim')
      let border_opts = extend({'is_frame': 1,}, border_opts)
      let frame = s:create_float('Normal', border_opts)
      call nvim_buf_set_lines(frame, 0, -1, v:true, border)
      call s:create_float('Normal', opts)
    else
      let opts = extend({'is_frame': 1,}, border_opts)
      let frame = s:create_popup_window('Normal', border_opts)
      call setbufline(frame, 1, border)
      call s:create_popup_window('Normal', opts)
    endif
  endfunction
  function s:create_float(hl, opts) abort
    if has_key(a:opts, 'is_frame')
      unlet a:opts.is_frame
      let is_frame = "true"
    else
      let is_frame = "false"
    endif

    let buf = nvim_create_buf(v:false, v:true)
    let opts = extend({'relative': 'editor', 'style': 'minimal'}, a:opts)
    let win = nvim_open_win(buf, v:true, opts)
    call setwinvar(win, '&winhighlight', 'NormalFloat:'..a:hl)
    if l:is_frame == "true"
      " Close border window when terminal window close
      exe 'autocmd TermClose * ++once :bd! | call nvim_win_close('..l:win..', v:true)'
    endif
    return buf
  endfunction
  function s:create_popup_window(hl, opts) abort
    if has_key(a:opts, 'is_frame')
      let id = popup_create('', #{
            \ line: a:opts.line,
            \ col: a:opts.col,
            \ minwidth: a:opts.width,
            \ minheight: a:opts.height,
            \ zindex: 50,
            \ })
      call setwinvar(id, '&wincolor', a:hl)
      exe 'au BufWipeout * ++once call popup_close('..id..')'
      return winbufnr(id)
    else
      let buf = term_start(&shell, #{hidden: 1})
      call popup_create(buf, #{
            \ line: a:opts.line,
            \ col: a:opts.col,
            \ minwidth: a:opts.width,
            \ minheight: a:opts.height,
            \ zindex: 51,
            \ })
      exe 'au BufWipeout * ++once bw! '..buf
    endif
  endfunction
  function! s:openTerm(args, count, direction)
    let params = split(a:args)
    let direction = a:direction

    if a:direction == 3
      call s:openFloatBuffer()
    else
      call s:openBuffer(a:count, direction)
    endif

    exe 'terminal' a:args
    exe 'startinsert'
  endfunction
  command! -count -nargs=* TermHorizontal call s:openTerm(<q-args>, <count>, 0)
  command! -count -nargs=* TermVertical call s:openTerm(<q-args>, <count>, 1)
  command! -count -nargs=* TermFloat call s:openTerm(<q-args>, <count>, 3)
  if has('nvim-0.4') || has('patch-8.2.191')
    nnoremap <leader>R :TermFloat<CR>
  else
    nnoremap <leader>R :TermHorizontal<CR>
  endif

  tnoremap <Esc> <C-\><C-n>
  if has('nvim')
    augroup terminal_options
      autocmd!
      autocmd TermOpen term://*fzf* tnoremap <buffer> <Esc> <Esc>
      autocmd TermOpen * setlocal nonumber norelativenumber
    augroup END
  endif


" Coneallevel control
" ---------------------------------------------------------------------------------------
  function! ToggleConcealLevel()
    if &conceallevel == 0
      setlocal conceallevel=2
    else
      setlocal conceallevel=0
    endif
  endfunction
  nnoremap <silent> yoa :call ToggleConcealLevel()<CR>


" Change register
" ---------------------------------------------------------------------------------------
  function! ChangeReg() abort
    let r = nr2char(getchar())
    if r =~# '[a-zA-Z0-9"@\-:.%#=*"~_/]'
      call feedkeys("q:ilet @" . r . " = \<C-r>\<C-r>=string(@" . r . ")\<CR>\<ESC>", 'n')
    endif
  endfunction
  nnoremap <silent> rc :call ChangeReg()<CR>


" Move visual block
" ---------------------------------------------------------------------------------------
  vnoremap J :m '>+1<CR>gv=gv
  vnoremap K :m '<-2<CR>gv=gv


" Redirect the output of a Vim or external command into a scratch buffer
" https://gist.github.com/romainl/eae0a260ab9c135390c30cd370c20cd7
" ---------------------------------------------------------------------------------------
  function! Redir(cmd = '', rng = 0, start = 1, end = 1, bang = '')
    " get a clean command, without ^M at the end
    let cmd = a:cmd->trim()
    " close existing scratch windows
    for win in range(1, winnr('$'))
      if getwinvar(win, 'scratch')
        execute win . 'windo close'
      endif
    endfor
    " if called via :Redir!, assume the user wants to repeat the last Ex command
    if a:bang == '!' && cmd->empty()
      let cmd = expand(@:)->trim()
    endif
    " if cmd starts with !, assume it is an external command
    if cmd =~ '^!'
      let ext_cmd = cmd =~' %'
          \ ? matchstr(substitute(cmd, ' %', ' ' . shellescape(escape(expand('%:p'), '\')), ''), '^!\zs.*')
          \ : matchstr(cmd, '^!\zs.*')
      if a:rng == 0
        let output = systemlist(ext_cmd)
      else
        let joined_lines = join(getline(a:start, a:end), '\n')
        let cleaned_lines = substitute(shellescape(joined_lines), "'\\\\''", "\\\\'", 'g')
        let output = systemlist(ext_cmd . " <<< $" . cleaned_lines)
      endif
    " if not, assume it is a Vim command
    else
      redir => output
      execute cmd
      redir END
      let output = split(output, "\n")
    endif
    " open a new window
    vnew
    " flag it as a scratch window
    let w:scratch = 1
    " make it a scratch window
    setlocal buftype=nofile bufhidden=wipe nobuflisted noswapfile
    " fill the buffer with the output of the given command
    call setline(1, output)
  endfunction

  command! -nargs=? -complete=command -bar -range -bang Redir silent call Redir(<q-args>, <range>, <line1>, <line2>, '<bang>')


" Improved grep 
" https://gist.github.com/romainl/56f0c28ef953ffc157f36cc495947ab3
" ---------------------------------------------------------------------------------------
  function! Grep(...)
    " neovim v0.4.4 has no expandcmd()
    let args = map(copy(a:000), 'shellescape(expand(v:val))')
    let cmd = join([&grepprg] + l:args)
    echo l:cmd
    return system(l:cmd)
  endfunction
  command! -nargs=+ -complete=file_in_path -bar Grep  cgetexpr Grep(<f-args>)
  command! -nargs=+ -complete=file_in_path -bar LGrep lgetexpr Grep(<f-args>)
  " Open the location/quickfix window automatically if there are valid entries in the list
  augroup quickfix
    autocmd!
    autocmd QuickFixCmdPost cgetexpr cwindow
    autocmd QuickFixCmdPost lgetexpr lwindow
  augroup END
  cnoreabbrev <expr> grep (getcmdtype() ==# ':' && getcmdline() ==# 'grep') ? 'Grep' : 'grep'
  cnoreabbrev <expr> lgrep (getcmdtype() ==# ':' && getcmdline() ==# 'lgrep') ? 'LGrep' : 'lgrep'


" yanking
" ---------------------------------------------------------------------------------------
  " reselect the yanked region with `gb`
  nnoremap <expr> gb '`[' . strpart(getregtype(), 0, 1) . '`]'
  " paste without yanking in visual mode with `P`
  xnoremap <expr> P '"_d"'.v:register.'P'


" Output the current syntax group
" ---------------------------------------------------------------------------------------
  nnoremap <leader>hg :echo "hi<" . synIDattr(synID(line("."),col("."),1),"name") . '> trans<'
        \ . synIDattr(synID(line("."),col("."),0),"name") . "> lo<"
        \ . synIDattr(synIDtrans(synID(line("."),col("."),1)),"name") . ">"<cr>


" Readline-style key bindings in command-line (excerpt from rsi.vim)
" ---------------------------------------------------------------------------------------
  cnoremap <C-A> <Home>
  cnoremap <C-B> <Left>
  cnoremap <M-b> <S-Left>
  cnoremap <M-f> <S-Right>


" shebang
" ---------------------------------------------------------------------------------------
  inoreabbrev <expr> #!! "#!/usr/bin/env" . (empty(&filetype) ? '' : ' '.&filetype)


" scroll more
" ---------------------------------------------------------------------------------------
  nnoremap <C-e> 2<C-e>
  nnoremap <C-y> 2<C-y>


" }}}
" =======================================================================================
" FUNCTIONS {{{
" =======================================================================================


" neovim python support
" ---------------------------------------------------------------------------------------
  if has('nvim')
    let g:python_host_prog = system("echo -n $HOME/.virtualenvs/neovim2/bin/python")
    let g:python3_host_prog = system("echo -n $HOME/.virtualenvs/neovim3/bin/python")
  endif


" Remove trailing whitespaces on save
" ---------------------------------------------------------------------------------------
  function! StripTrailingWhitespaces()
    let l = line(".")
    let c = col(".")
    %s/\s\+$//e
    call cursor(l, c)
  endfunction
  autocmd FileType c,cpp,java,javascript,html,ruby,python,pandoc
        \ autocmd BufWritePre <buffer> :call StripTrailingWhitespaces()


" Disable few things on file larger than 250mb
" ---------------------------------------------------------------------------------------
  let g:LargeFile = 1024 * 1024 * 250
  augroup LargeFile
    autocmd BufReadPre * let f=getfsize(expand("<afile>")) | if f > g:LargeFile || f == -2 | call LargeFile() | endif
  augroup END

  function! LargeFile()
    " no syntax highlighting etc
    " set eventignore+=FileType
    " save memory when other file is viewed
    setlocal bufhidden=unload
    " is read-only (write with :w new_filename)
    setlocal buftype=nowrite
    " no undo possible
    setlocal undolevels=-1
    " display message
    autocmd VimEnter *  echo 'The file is larger than ' . (g:LargeFile / 1024 / 1024) . ' MB, so some options are changed (see .vimrc for details).'
  endfunction


" Vim jump to the last position when reopening a file
" ---------------------------------------------------------------------------------------
  autocmd BufReadPost * if line("'\"") > 1 && line("'\"") <= line("$") | exe "normal! g'\"" | endif


" auto marker
" ---------------------------------------------------------------------------------------
  augroup contextswitch
    autocmd!
    autocmd BufLeave *.py           normal! mP
    autocmd BufLeave *.yaml,*.yml   normal! mY
    autocmd BufLeave *.md           normal! mM
  augroup END


" copy the current file's full absolute path.
" ---------------------------------------------------------------------------------------
  command! CopyFilePath call s:yank(expand(has('win32') ? '%:p:gs?/?\\?' : '%:p'))


" copy the current file's name.
" ---------------------------------------------------------------------------------------
  command! CopyFileName call s:yank(expand(has('win32') ? '%:t:gs?/?\\?' : '%:t'))


" copy the directory where current file is in.
" ---------------------------------------------------------------------------------------
  command! CopyFileDir call s:yank(expand(has('win32') ? '%:p:h:gs?/?\\?' : '%:p:h'))


" go to current file directory
" ---------------------------------------------------------------------------------------
  function! Cd()
    if !empty($TMUX)
      call system("tmux new-window -c " . expand('%:p:h'))
    else
      echo "You are not in tmux session. Copy directory into clipboard instead."
      execute 'CopyFileDir'
    endif
  endfunction
  command! Cd call Cd()


" Custom location for quickfix and loclist
" ---------------------------------------------------------------------------------------
  function! s:customiseLocation()
    " if loclist, put it below the current window
    if getwininfo(win_getid())[0]['loclist'] == 1
    " if quickfix, put it bellow the whole window
    elseif getwininfo(win_getid())[0]['quickfix'] == 1
      wincmd J
    endif
  endfunction
  augroup customLocationForQF
    autocmd!
    autocmd FileType qf call s:customiseLocation()
  augroup END


" Edit quickfix and loclist
" ---------------------------------------------------------------------------------------
  function! s:removeQfAtCursor() abort
    let currline = line('.')
    let items = getqflist()->filter({ index -> (index + 1) != currline })
    call setqflist(items, 'r')
    execute 'normal ' . currline . 'G'
  endfunction

  function! s:removeQfFromSelected() abort
    let startline = line("'<")
    let endline = line("'>")
    let items = getqflist()->filter({ index -> (index + 1) < startline || (index + 1) > endline })
    call setqflist(items, 'r')
    execute 'normal ' . startline . 'G'
  endfunction

  augroup removeQf
    autocmd!
    autocmd FileType qf nnoremap <buffer><silent> dd :call <SID>removeQfAtCursor()<CR>
    autocmd FileType qf vnoremap <buffer><silent> x :call <SID>removeQfFromSelected()<CR>
  augroup END


" jumpfile
" ---------------------------------------------------------------------------------------
  " https://gist.github.com/EgZvor/e804cdd8259455a41eaa9f6ed0cdde53
  function! JumpFileComputePrevious()
    let [jump_list, pos] = getjumplist()
    let previous_list = jump_list
      \ ->map({idx, val -> [idx, val]})[:pos]
      \ ->reverse()
      \ ->filter({idx, pos_b -> pos_b[1].bufnr != bufnr()})
    if previous_list != []
      return pos - previous_list[0][0]
    else
      return 0
    endif
  endfunction

  function! JumpFileComputeNext()
    let [jump_list, pos] = getjumplist()
    let next_list = jump_list
      \ ->map({idx, val -> [idx, val]})[pos:]
      \ ->filter({idx, pos_b -> pos_b[1].bufnr != bufnr()})
    if next_list != []
      return next_list[0][0] - pos
    else
      return 0
    endif
  endfunction

  nnoremap <leader><c-o> <cmd>execute 'normal ' . JumpFileComputePrevious() . "\<c-o>"<cr>
  nnoremap <leader><c-i> <cmd>execute 'normal ' . JumpFileComputeNext() . "\<c-i>"<cr>


" plugin install check
" ---------------------------------------------------------------------------------------
  function! HasPlug(name) abort
    return has_key(g:plugs, a:name)
  endfunction

  function! IsPlugInstalled(name) abort
    return has_key(g:plugs, a:name) && isdirectory(g:plugs[a:name].dir)
  endfunction


" Close all floating windows
" https://github.com/wookayin/dotfiles/commit/96d935515486f44ec361db3df8ab9ebb41ea7e40
" ---------------------------------------------------------------------------------------
  if has('nvim-0.4.0')
    command! CloseAllFloatingWindows lua _G.CloseAllFloatingWindows()
    lua <<EOF
    _G.CloseAllFloatingWindows = function()
      local closed_windows = {}
      for _, win in ipairs(vim.api.nvim_list_wins()) do
        local config = vim.api.nvim_win_get_config(win)
        if config.relative ~= "" then  -- is_floating_window?
          vim.api.nvim_win_close(win, false)  -- do not force
          table.insert(closed_windows, win)
        end
      end
      print(string.format('Closed %d windows: %s', #closed_windows, vim.inspect(closed_windows)))
    end
EOF
  endif

" Toggle current word
" https://github.com/habamax/.vim/blob/72ef8cb1c3938766437533af1e64ce1a164fb9bd/autoload/text.vim#L305
" ---------------------------------------------------------------------------------------
  function! ToggleWord()
    let toggles = {
          \ 'true': 'false', 'false': 'true', 'True': 'False', 'False': 'True', 'TRUE': 'FALSE', 'FALSE': 'TRUE',
          \ 'yes': 'no', 'no': 'yes', 'Yes': 'No', 'No': 'Yes', 'YES': 'NO', 'NO': 'YES',
          \ 'on': 'off', 'off': 'on', 'On': 'Off', 'Off': 'On', 'ON': 'OFF', 'OFF': 'ON',
          \ 'open': 'close', 'close': 'open', 'Open': 'Close', 'Close': 'Open',
          \ 'dark': 'light', 'light': 'dark',
          \ 'width': 'height', 'height': 'width',
          \ 'first': 'last', 'last': 'first',
          \ 'top': 'right', 'right': 'bottom', 'bottom': 'left', 'left': 'center', 'center': 'top',
          \ }
    let word = expand("<cword>")
    if has_key(toggles, word)
      execute 'normal! "_ciw' .. toggles[word]
    endif
  endfunction

  nnoremap <leader>tw <cmd>call ToggleWord()<CR>


" }}}
" =======================================================================================
" PLUGINS SETTINGS {{{
" =======================================================================================


" tpope/vim-fugitive
" ---------------------------------------------------------------------------------------
  if IsPlugInstalled('vim-fugitive')
    nnoremap <leader>gs :Git<CR>
    nnoremap <leader>gd :Gvdiffsplit<CR>
  endif


" rhysd/git-messenger.vim
" ---------------------------------------------------------------------------------------
  if IsPlugInstalled('git-messenger.vim')
    let g:git_messenger_no_default_mappings = v:true
    let g:git_messenger_include_diff = "current"
    nmap <leader>gm <Plug>(git-messenger)

    function! s:setup_git_messenger_popup() abort
      " set go back/forward history to <C-o>/<C-i>
      nmap <buffer><C-o> o
      nmap <buffer><C-i> O
    endfunction
    autocmd FileType gitmessengerpopup call <SID>setup_git_messenger_popup()
  endif


" scrooloose/nerdcommenter
" ---------------------------------------------------------------------------------------
  if IsPlugInstalled('nerdcommenter')
    " Add spaces after comment delimiters by default
    let g:NERDSpaceDelims = 1
    " Use compact syntax for prettified multi-line comments
    let g:NERDCompactSexyComs = 1
    " Align line-wise comment delimiters flush left instead of following code indentation
    let g:NERDDefaultAlign = 'left'
    " Set a language to use its alternate delimiters by default
    let g:NERDAltDelims_java = 1
    " Add your own custom formats or override the defaults
    let g:NERDCustomDelimiters = { 'c': { 'left': '/**','right': '*/' } }
    " Allow commenting and inverting empty lines (useful when commenting a region)
    let g:NERDCommentEmptyLines = 1
    " Enable trimming of trailing whitespace when uncommenting
    let g:NERDTrimTrailingWhitespace = 1
    " Enable NERDCommenterToggle to check all selected lines is commented or not
    let g:NERDToggleCheckAllLines = 1
  endif


" junegunn/fzf.vim
" ---------------------------------------------------------------------------------------
  if IsPlugInstalled('fzf.vim')
    nnoremap <leader>F :Files<CR>
    nnoremap <leader>B :Buffers<CR>
    nnoremap <leader>P :ProjectFiles<CR>

    " Search project root
    function! s:find_git_root()
      return system('git rev-parse --show-toplevel 2> /dev/null')[:-2]
    endfunction
    command! ProjectFiles execute 'Files' s:find_git_root()

    " Customize fzf colors to match your color scheme
    let g:fzf_colors = {
          \ 'fg':      ['fg', 'Normal'],
          \ 'bg':      ['bg', 'Normal'],
          \ 'hl':      ['fg', 'Comment'],
          \ 'fg+':     ['fg', 'CursorLine', 'CursorColumn', 'Normal'],
          \ 'bg+':     ['bg', 'CursorLine', 'CursorColumn'],
          \ 'hl+':     ['fg', 'Statement'],
          \ 'info':    ['fg', 'PreProc'],
          \ 'border':  ['fg', 'Ignore'],
          \ 'prompt':  ['fg', 'Conditional'],
          \ 'pointer': ['fg', 'Exception'],
          \ 'marker':  ['fg', 'Keyword'],
          \ 'spinner': ['fg', 'Label'],
          \ 'header':  ['fg', 'Comment'],
          \ }

    " Rg: start fzf
    " Rg!: start fzf with preview window
    command! -bang -nargs=* Rg
          \ call fzf#vim#grep(
          \   'rg --column --line-number --no-heading --color=always --smart-case '.shellescape(<q-args>), 1,
          \   <bang>0 ? fzf#vim#with_preview('up:60%')
          \           : fzf#vim#with_preview('right:50%:hidden', '?'),
          \   <bang>0)

    " http://ericnode.info/post/fzf_jump_to_tab_in_vim/
    " tab navigation
    function! TabName(n)
      let buflist = tabpagebuflist(a:n)
      let winnr = tabpagewinnr(a:n)
      return fnamemodify(bufname(buflist[winnr - 1]), ':.')
    endfunction
    function! s:jumpToTab(line)
      let pair = split(a:line, ' ')
      let cmd = pair[0].'gt'
      execute 'normal' cmd
    endfunction
    nnoremap <silent> <Leader>T :call fzf#run(fzf#wrap({
    \   'source':  reverse(map(range(1, tabpagenr('$')), 'v:val." "." ".TabName(v:val)')),
    \   'sink':    function('<sid>jumpToTab')
    \ }))<CR>

  endif


" christoomey/vim-tmux-navigator
" ---------------------------------------------------------------------------------------
  if IsPlugInstalled('vim-tmux-navigator')
    let g:tmux_navigator_no_mappings = 1

    nnoremap <silent> <C-h> :TmuxNavigateLeft<cr>
    nnoremap <silent> <C-j> :TmuxNavigateDown<cr>
    nnoremap <silent> <C-k> :TmuxNavigateUp<cr>
    nnoremap <silent> <C-l> :TmuxNavigateRight<cr>
    nnoremap <silent> <C-\> :TmuxNavigatePrevious<cr>
    " Disable tmux navigator when zooming the Vim pane
    let g:tmux_navigator_disable_when_zoomed = 1
  endif


" junegunn/vim-easy-align
" ---------------------------------------------------------------------------------------
  if IsPlugInstalled('vim-easy-align')
    " Start interactive EasyAlign in visual mode (e.g. vipga)
    xmap ga <Plug>(EasyAlign)
    " Start interactive EasyAlign for a motion/text object (e.g. gaip)
    nmap ga <Plug>(EasyAlign)
  endif


" junegunn/gv.vim
" ---------------------------------------------------------------------------------------
  if IsPlugInstalled('gv.vim')
    function! s:gv_expand()
      let line = getline('.')
      GV --name-status
      call search('\V'.line, 'c')
      normal! zz
    endfunction
    autocmd! FileType GV nnoremap <buffer> <silent> + :call <sid>gv_expand()<cr>
  endif


" mhinz/vim-startify
" ---------------------------------------------------------------------------------------
  if IsPlugInstalled('vim-startify')
    nnoremap <leader>S :Startify<CR>

    let s:dotfiles_path = fnamemodify(resolve($MYVIMRC), ':h:h')

    let g:startify_bookmarks = [
          \ { 'a': $MYVIMRC },
          \ { 's': s:dotfiles_path . '/tmux/tmux.conf' },
          \ { 'z': s:dotfiles_path . '/zsh/zshrc' },
          \ { 'x': s:dotfiles_path . '/zsh/zpreztorc' },
          \ { 'c': s:dotfiles_path . '/config/fish/config.fish' },
          \]
    let g:startify_change_to_dir = 0
  endif


" unblevable/quick-scope
" ---------------------------------------------------------------------------------------
  if IsPlugInstalled('quick-scope')
    let g:qs_highlight_on_keys = ['f', 'F', 't', 'T']
  endif


" tpope/vim-unimpaired
" ---------------------------------------------------------------------------------------
  if IsPlugInstalled('vim-unimpaired')
    let g:nremap = {"[t": "", "]t": "", "[T": "", "]T": ""}
  endif


" tpope/vim-dispatch
" ---------------------------------------------------------------------------------------
  if IsPlugInstalled('vim-dispatch')
    let g:dispatch_no_maps = 1
  endif


" Yggdroot/indentLine
" ---------------------------------------------------------------------------------------
  if IsPlugInstalled('indentLine')
    let g:indentLine_enabled = 1
    let g:indentLine_faster = 1
    " let g:indentLine_setColors = 0
    let g:indentLine_defaultGroup = 'SpecialKey'
    " let g:indentLine_setConceal = 0
    " let g:indentLine_char = 'â”Š'
    " let g:indentLine_char_list = ['|', 'Â¦', 'â”†', 'â”Š']
  endif


" lukas-reineke/indent-blankline.nvim
" ---------------------------------------------------------------------------------------
  if IsPlugInstalled('indent-blankline.nvim')
    lua require('plugins.indent-blankline').setup({})
  endif


" neoclide/coc.nvim
" ---------------------------------------------------------------------------------------
  if IsPlugInstalled('coc.nvim')
    let g:coc_global_extensions = [
          \ 'coc-emoji', 'coc-snippets', 'coc-highlight', 'coc-json', 'coc-tsserver',
          \ 'coc-html', 'coc-css', 'coc-yaml', 'coc-vimtex', 'coc-pyright', 'coc-go',
          \ 'coc-sh', 'coc-vimlsp',
          \ ]

    if executable('ccls')
      call coc#config('languageserver.ccls', {
            \ 'command': 'ccls',
            \ 'filetypes': ['c', 'cpp', 'objc', 'objcpp'],
            \ 'rootPatterns': ['.ccls', 'compile_commands.json', '.vim/', '.git/', '.hg/'],
            \ 'initializationOptions': {
            \   'cache': {
            \   'directory': '/tmp/ccls'
            \   }
            \ }
            \})
    endif

    " Use tab for trigger completion with characters ahead and navigate.
    " NOTE: Use command ':verbose imap <tab>' to make sure tab is not mapped by
    " other plugin before putting this into your config.
    inoremap <silent><expr> <TAB>
          \ pumvisible() ? "\<C-n>" :
          \ <SID>check_back_space() ? "\<TAB>" :
          \ coc#refresh()
    inoremap <expr><S-TAB> pumvisible() ? "\<C-p>" : "\<C-h>"

    function! s:check_back_space() abort
      let col = col('.') - 1
      return !col || getline('.')[col - 1]  =~# '\s'
    endfunction

    " Use <c-j> to trigger completion.
    inoremap <silent><expr> <c-j> coc#refresh()

    " Use <C-l> for trigger snippet expand.
    imap <C-l> <Plug>(coc-snippets-expand)

    " Use <C-j> for select text for visual placeholder of snippet.
    vmap <C-j> <Plug>(coc-snippets-select)

    " Use <C-j> for jump to next placeholder, it's default of coc.nvim
    let g:coc_snippet_next = '<c-j>'

    " Use <C-k> for jump to previous placeholder, it's default of coc.nvim
    let g:coc_snippet_prev = '<c-k>'

    " " Use `[d` and `]d` to navigate diagnostics
    " " Use `:CocDiagnostics` to get all diagnostics of current buffer in location list.
    " nmap <silent> [d <Plug>(coc-diagnostic-prev)
    " nmap <silent> ]d <Plug>(coc-diagnostic-next)

    " GoTo code navigation.
    nmap <silent> gd <Plug>(coc-definition)
    nmap <silent> gy <Plug>(coc-type-definition)
    nmap <silent> gc <Plug>(coc-implementation)
    nmap <silent> gr <Plug>(coc-references)

    function! SplitIfNotOpen(...)
      let fname = a:1
      let call = ''
      if a:0 == 2
        let fname = a:2
        let call = a:1
      endif
      let bufnum=bufnr(expand(fname))
      let winnum=bufwinnr(bufnum)
      if winnum != -1
        " Jump to existing split
        exe winnum . "wincmd w"
      else
        " Make new split as usual
        exe "vsplit " . fname
      endif
      " Execute the cursor movement command
      exe call
    endfunction
    command! -nargs=+ CocSplitIfNotOpen :call SplitIfNotOpen(<f-args>)

    " Use K to show documentation in preview window.
    nnoremap <silent> K :call <SID>show_documentation()<CR>

    function! s:show_documentation()
      if (index(['vim','help'], &filetype) >= 0)
        execute 'h '.expand('<cword>')
      else
        call CocAction('doHover')
      endif
    endfunction

    " Highlight the symbol and its references when holding the cursor.
    autocmd CursorHold * silent call CocActionAsync('highlight')

    " Symbol renaming.
    nmap <leader>rn <Plug>(coc-rename)

    " Formatting selected code.
    xmap <leader>f  <Plug>(coc-format-selected)
    nmap <leader>f  <Plug>(coc-format-selected)

    " Add `:Format` command to format current buffer.
    command! -nargs=0 Format :call CocAction('format')

    " Add `:OR` command for organize imports of the current buffer.
    command! -nargs=0 OR     :call CocAction('runCommand', 'editor.action.organizeImport')

    " Add `:Fold` command to fold current buffer.
    command! -nargs=? Fold   :call CocAction('fold', <f-args>)

  endif

  echo expand('<abuf>')


" fatih/vim-go
" ---------------------------------------------------------------------------------------
  if IsPlugInstalled('vim-go')
    " disable mapping
    let g:go_def_mapping_enabled = 0
    let g:go_doc_keywordprg_enabled = 0
    " disable completion
    let g:go_code_completion_enabled = 0
    " diable all syntax highlight
    if !IsPlugInstalled('nvim-treesitter')
      let g:go_highlight_fields = 1
      let g:go_highlight_structs = 1
      let g:go_highlight_methods = 1
      let g:go_highlight_functions = 1
      let g:go_highlight_operators = 1
      let g:go_highlight_build_constraints = 1
      let g:go_highlight_function_parameters = 1
      let g:go_highlight_function_calls = 1
      let g:go_highlight_format_strings = 1
    endif
  endif


" liuchengxu/vista.vim
" ---------------------------------------------------------------------------------------
  if IsPlugInstalled('vista.vim')
    nmap <leader>V :Vista!!<CR>

    let g:vista_icon_indent = ["â–¸ ", ""]

    let g:vista#renderer#enable_icon = 1
    let g:vista#renderer#icons = {
          \   "function": "\uf794",
          \   "variable": "\uf71b",
          \  }

    let g:vista_default_executive = 'ctags'

    let g:vista_executive_for = {
          \ 'vim': 'nvim_lsp',
          \ 'sh': 'nvim_lsp',
          \ 'python': 'nvim_lsp',
          \ 'yaml': 'nvim_lsp',
          \ 'tex': 'nvim_lsp',
          \ 'go': 'nvim_lsp',
          \ }
  endif


" iamcco/markdown-preview.nvim
" ---------------------------------------------------------------------------------------
  if IsPlugInstalled('markdown-preview.nvim')
    let g:mkdp_echo_preview_url = 1
    let g:mkdp_open_to_the_world = 1
    let g:mkdp_port = '40100'

    function! g:OpenBrowser(url)
      call s:yank(a:url)
      if has('mac')
        silent exe 'silent !open -na "Google Chrome" --args --incognito --new-window ' . a:url
      endif
    endfunction
    let g:mkdp_browserfunc = 'g:OpenBrowser'
  endif


" liuchengxu/vim-which-key
" ---------------------------------------------------------------------------------------
  if IsPlugInstalled('vim-which-key')
    nnoremap <silent> <leader> :<c-u>WhichKey '\'<CR>
  endif


" tpope/vim-vinegar
" ---------------------------------------------------------------------------------------
  if IsPlugInstalled('vim-vinegar')
    " https://github.com/tpope/vim-vinegar/issues/13#issuecomment-489440040
    let g:netrw_fastbrowse = 0
  endif


" kkoomen/vim-doge
" ---------------------------------------------------------------------------------------
  if IsPlugInstalled('vim-doge')
    let g:doge_mapping = '<Leader>D'
    let g:doge_doc_standard_python = 'google'
  endif


" LunarWatcher/auto-pairs
" ---------------------------------------------------------------------------------------
  if IsPlugInstalled('auto-pairs')
    let g:AutoPairsMapBS = 0
    let g:AutoPairsMultilineBackspace = 0
    let g:AutoPairsShortcutFastWrap = "<c-f>"
    " disable all other mappings
    let g:AutoPairsShortcutToggle = ""
    let g:AutoPairsShortcutIgnore = ""
    let g:AutoPairsShortcutJump = ""
    let g:AutoPairsShortcutBackInsert = ""
    let g:AutoPairsMoveExpression = ""
    let g:AutoPairsShortcutToggleMultilineClose = ""
  endif


" AndrewRadev/splitjoin.vim
" ---------------------------------------------------------------------------------------
  if IsPlugInstalled('splitjoin.vim')
    let g:splitjoin_python_brackets_on_separate_lines = 1
  endif


" nvim-tree/nvim-web-devicons
" ---------------------------------------------------------------------------------------
  if IsPlugInstalled('nvim-web-devicons')
    lua require('plugins.nvim-web-devicons').setup({})
  endif


" folke/which-key.nvim
" ---------------------------------------------------------------------------------------
  if IsPlugInstalled('which-key.nvim')
    lua require('plugins.which-key').setup({})
  endif


" nvim-treesitter/nvim-treesitter
" ---------------------------------------------------------------------------------------
  if IsPlugInstalled('nvim-treesitter')
    lua require('plugins.nvim-treesitter').setup({})
  endif


" nvim-treesitter/nvim-treesitter-context
" ---------------------------------------------------------------------------------------
  if IsPlugInstalled('nvim-treesitter-context')
    lua require('plugins.nvim-treesitter-context').setup({})
  endif


" neovim/nvim-lspconfig
" ---------------------------------------------------------------------------------------
  if IsPlugInstalled('nvim-lspconfig')
    lua require('config.lsp').setup({})
  endif


" mfussenegger/nvim-dap
" ---------------------------------------------------------------------------------------
  if IsPlugInstalled('nvim-dap')
    lua require('config.dap').setup({})
  endif


" lewis6991/gitsigns.nvim
" ---------------------------------------------------------------------------------------
  if IsPlugInstalled('gitsigns.nvim')
    lua require('plugins.gitsigns').setup({})
  endif


" hood/popui.nvim
" ---------------------------------------------------------------------------------------
  if IsPlugInstalled('popui.nvim')
    lua require('plugins.popui').setup({})
  endif

" windwp/nvim-ts-autotag
" ---------------------------------------------------------------------------------------
  if IsPlugInstalled('nvim-ts-autotag')
    lua require('nvim-ts-autotag').setup({})
  endif

" dmmulroy/ts-error-translator.nvim
" ---------------------------------------------------------------------------------------
  if IsPlugInstalled('ts-error-translator.nvim')
    lua require('ts-error-translator').setup({})
  endif

" andrewferrier/debugprint.nvim
" ---------------------------------------------------------------------------------------
  if IsPlugInstalled('debugprint.nvim')
    lua require('debugprint').setup({})
  endif
" }}}
