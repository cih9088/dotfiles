" vim: set foldmethod=marker foldlevel=0 nomodeline:

" =======================================================================================
" PLUGINS {{{
" =======================================================================================

" vim-plugin
" ---------------------------------------------------------------------------------------
  let data_dir = has('nvim') ? stdpath('data') . '/site' : '~/.vim'
  if empty(glob(data_dir . '/autoload/plug.vim'))
    silent execute '!curl -fLo '.data_dir.'/autoload/plug.vim --create-dirs https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim'
    autocmd VimEnter * PlugInstall --sync | source $MYVIMRC
  endif

  call plug#begin(has('nvim') ? stdpath('data') . '/plugged' : '~/.vim/plugged')

" Prettier
" ---------------------------------------------------------------------------------------
  Plug 'ryanoasis/vim-devicons'
  Plug 'junegunn/seoul256.vim'
  Plug 'morhetz/gruvbox'
  Plug 'w0ng/vim-hybrid'
  Plug 'joshdick/onedark.vim'
  Plug 'dracula/vim', { 'as': 'dracula' }
  Plug 'sainnhe/edge'


" Convenient Universally
" ---------------------------------------------------------------------------------------
  Plug 'scrooloose/nerdcommenter'
  Plug 'christoomey/vim-tmux-navigator'
  Plug 'junegunn/vim-easy-align', { 'on': '<Plug>(EasyAlign)' }
  Plug 'junegunn/gv.vim', { 'on': ['GV', 'GV!'] }
  Plug 'junegunn/vim-peekaboo'
  Plug 'junegunn/fzf', { 'do': { -> fzf#install() } }
  Plug 'junegunn/fzf.vim'
  Plug 'unblevable/quick-scope'
  Plug 'tpope/vim-fugitive'
  Plug 'tpope/vim-rhubarb'
  Plug 'tpope/vim-repeat'
  Plug 'tpope/vim-surround'
  Plug 'tpope/vim-unimpaired'
  " Plug 'tpope/vim-obsession'
  Plug 'tpope/vim-abolish'
  Plug 'mhinz/vim-signify'
  if has('nvim-0.4.0') && exists('*nvim_open_win')
    Plug 'rhysd/git-messenger.vim'
  endif
  Plug 'AndrewRadev/splitjoin.vim'
  Plug 'Yggdroot/indentLine'
  if has("nvim-0.5")
    Plug 'nvim-treesitter/nvim-treesitter', { 'do': ':TSUpdate' }
  elseif has('nvim')
  " Plug 'numirias/semshi', { 'do': ':UpdateRemotePlugins', 'for': 'python' }
  endif
  " Plug 'preservim/nerdtree'
  Plug 'tpope/vim-vinegar'
  Plug 'liuchengxu/vista.vim'
  Plug 'kkoomen/vim-doge', { 'do': { -> doge#install() } }


" Language Specific
" ---------------------------------------------------------------------------------------
  Plug 'neoclide/coc.nvim', { 'branch': 'release' }
  Plug 'honza/vim-snippets'
  Plug 'dag/vim-fish', { 'for': 'fish' }
  Plug 'Vimjas/vim-python-pep8-indent', { 'for': 'python' }
  Plug 'lervag/vimtex', { 'for': 'tex' }
  Plug 'pearofducks/ansible-vim'
  Plug 'plasticboy/vim-markdown', { 'for': 'markdown' }
  Plug 'mzlogin/vim-markdown-toc', { 'for': 'markdown' }
  Plug 'fatih/vim-go', { 'do': ':GoUpdateBinaries', 'for': 'go' }
  if has('nvim') || v:version >= 800
    Plug 'iamcco/markdown-preview.nvim',
          \ { 'do': ':call mkdp#util#install()', 'for': 'markdown', 'on': 'MarkdownPreview' }
  endif

" Etc.
" ---------------------------------------------------------------------------------------
  Plug 'mhinz/vim-startify'
  Plug 'wellle/tmux-complete.vim'
  Plug 'liuchengxu/vim-which-key', { 'on': ['WhichKey', 'WhichKey!'] }


" Initialize plugin system
" ---------------------------------------------------------------------------------------
  call plug#end()



" }}}
" =======================================================================================
" BASIC SETTING {{{
" =======================================================================================

" General
" --------------------------------------------------------------------------------------
  filetype plugin indent on             " Enable filetype plugins
  syntax enable                         " enable syntax processing
  set autoread                          " auto read when a file is changed from the outside

  set nocompatible                      " do not compatible to original vi
  set wrap
  set nowrapscan                        " do not go back to the first of the line when it reaches at the end of the line
  set nobackup                          " do not create backup file
  set noswapfile                        " do not create swap file
  set visualbell                        " visualbell on
  set fencs=ucs-bom,utf-8,euc-kr.latin1 " hangle goes euc-kr, unicode goes unicode
  set fileencoding=utf-8                " file saving encoding
  set tenc=utf-8                        " terminal encoding
  set backspace=eol,start,indent        " go to earlier line where the cursor is positioned at end of the line, start of the line and indent
  set hidden                            " unsaved changes in buffer is hidden not quit
  set history=1000                      " remember more commands and search history
  set undofile                          " Maintain undo history between sessions
  set undolevels=1000                   " use many muchos levels of undo
  set undodir=~/.vim/undodir
  set laststatus=2                      " status bar is always on
  set showtabline=2                     " tab bar is always on
  set signcolumn=yes                    " always draw the sign column
  set linebreak
  set colorcolumn=90                    " color column to limit coding length
  set pastetoggle=<F2>                  " when in insert mode, press <F2> to go to
                                        " pasete mode, where you can paste mass data
                                        " that won't be autoindent
  set scrolloff=5                       " When scrolling, keep cursor 5 lines away from screen border
  set cmdheight=2                       " Give more space for displaying messages.
  set updatetime=300                    " Having longer updatetime (default is 4000 ms = 4 s) leads to noticeable
                                        " delays and poor user experience.
  set shortmess+=c                      " Don't pass messages to ins-completion-menu.

  " Always show the signcolumn, otherwise it would shift the text each time
  " diagnostics appear/become resolved.
  if has("patch-8.1.1564")
    " Recently vim can merge signcolumn and number column into one
    set signcolumn=number
  else
    set signcolumn=yes
  endif

  set list                                                    " show unvisible characters
  set listchars=tab:»\ ,nbsp:␣,trail:·,extends:>,precedes:<   " set unvisible characters
  set showbreak=↪\                                            " set breakindent

  " visual autocomplete for command menu
  set wildmenu
  set wildmode=full
  " set wildmode=list:longest,full
  " Setting up ignores
  set wildignore+=*/tmp/*,*.so,*.pyc,*.png,*.jpg,*.gif,*.jpeg,*.ico,*.pdf
  set wildignore+=*.wav,*.mp4,*.mp3
  set wildignore+=*.o,*.out,*.obj,.git,*.rbc,*.rbo,*.class,.svn,*.gem
  set wildignore+=*.zip,*.tar.gz,*.tar.bz2,*.rar,*.tar.xz
  set wildignore+=*/vendor/gems/*,*/vendor/cache/*,*/.bundle/*,*/.sass-cache/*
  set wildignore+=*.swp,*~,._*
  set wildignore+=_pycache_,.DS_Store,.vscode,.localized

  " Resize panes whenever containing window resized.
  augroup resize_window
    autocmd!
    autocmd VimResized * wincmd =
  augroup END

  " diff: ignore whitespaces
  " https://www.micahsmith.com/blog/2019/11/fixing-vim-invalid-argument-diffopt-iwhite/
  if ! has('nvim')
    set diffopt-=internal
    set diffopt+=iwhite
  endif

  " only higlight the first 500 characters of each line to improve
  " performance for long line
  " set synmaxcol=500

  " Change grep to rg if it exists
  if executable('rg')
    set grepprg=rg\ -S\ --vimgrep
  endif



" Colorscheme
" ---------------------------------------------------------------------------------------

  " Terminal.app does not support truecolor
  if (has("termguicolors"))
    " set Vim-specific sequences for RGB colors
    let &t_8b = "\<Esc>[48;2;%lu;%lu;%lum"
    let &t_8f = "\<Esc>[38;2;%lu;%lu;%lum"
    set termguicolors
  endif

  set t_Co=256            " enable 256 color terminal


  " ChangeBackground changes theme and background
  function! ChangeBackground(...)
    " Change colorscheme
    try
      if a:0 > 0
        execute 'colorscheme ' . a:1
      else
        if !empty($TMUX)
          if system('tmux show-env COLOUR_SCHEME') !~# '^-.*'
            let l:scheme = split(trim(system('tmux show-env COLOUR_SCHEME')), '=')[1]
          endif
        else
          if exists('$COLOUR_SCHEME')
            let l:scheme = $COLOUR_SCHEME
          else
            let l:scheme = system('sed -En "s/^colors: \*(.*)/\1/p" ~/.config/alacritty/colour.yml')
          endif
        endif
      endif
      let l:colour =  matchstr(l:scheme, '[-_]\?\(light\|dark\)[-_]\?')
      let l:scheme_clenaed = substitute(l:scheme, l:colour, "", "")
      execute 'colorscheme ' . l:scheme_clenaed
    catch
      colorscheme default
    endtry

    " Change background
    if !empty($TMUX)
      if system('tmux show-env BG_LUMINANCE') !~# '^-.*'
        if split(trim(system('tmux show-env BG_LUMINANCE')), '=')[1] == "light"
          set background=light
        else
          set background=dark
        endif
      endif
    else
      if exists('$BG_LUMINANCE') && $BG_LUMINANCE == 'light'
        set background=light
      else
        set background=dark
      endif
    endif
  endfunction

  call ChangeBackground()

  " if has('nvim')
  "   let g:terminal_color_0  = '#4e4e4e'
  "   let g:terminal_color_1  = '#d68787'
  "   let g:terminal_color_2  = '#5f865f'
  "   let g:terminal_color_3  = '#d8af5f'
  "   let g:terminal_color_4  = '#85add4'
  "   let g:terminal_color_5  = '#d7afaf'
  "   let g:terminal_color_6  = '#87afaf'
  "   let g:terminal_color_7  = '#d0d0d0'
  "   let g:terminal_color_8  = '#626262'
  "   let g:terminal_color_9  = '#d75f87'
  "   let g:terminal_color_10 = '#87af87'
  "   let g:terminal_color_11 = '#ffd787'
  "   let g:terminal_color_12 = '#add4fb'
  "   let g:terminal_color_13 = '#ffafaf'
  "   let g:terminal_color_14 = '#87d7d7'
  "   let g:terminal_color_15 = '#e4e4e4'
  " else
  "   let g:terminal_ansi_colors = [
  "         \ '#4e4e4e', '#d68787', '#5f865f', '#d8af5f',
  "         \ '#85add4', '#d7afaf', '#87afaf', '#d0d0d0',
  "         \ '#626262', '#d75f87', '#87af87', '#ffd787',
  "         \ '#add4fb', '#ffafaf', '#87d7d7', '#e4e4e4']
  " endif


" Spaces & Tabs
" ---------------------------------------------------------------------------------------
  set tabstop=2       " number of visual spaces per TAB
  set softtabstop=2   " number of spaces in tab when editing
  set expandtab       " tabs are spaces
  set shiftwidth=2    " auto indent 2
  set cindent         " indent only for C language
  set smartindent     " smart indentation
  set copyindent      " copy the previous indentation on autoindenting
  set autoindent      " always set autoindenting on
  " autocmd FileType yaml setlocal tabstop=2 softtabstop=2 shiftwidth=2


" UI Config
" ---------------------------------------------------------------------------------------
  set ruler           " show line and col
  set relativenumber  " show relative line numbers
  set number          " show absolute line numbers where your cursor is
  set numberwidth=3   " keep the line number gutter narrow
  set showcmd         " show command in bottom bar
  set cursorline      " highlight current line
  set showmatch       " highlight matching [{()}]
  set title           " change the terminal's title
  set lazyredraw      " redraw only when we need to
  set noshowmode      " for echodoc to hide -- INSERT -- in command line


" Searching
" ---------------------------------------------------------------------------------------
  set incsearch       " show search matches as you type
  set hlsearch        " highlight mtches
  set ignorecase      " ignore case when searching
  set smartcase       " ignore case if search pattern is all lowercase,
                      " case-sensitive otherwise

" Folding
" ---------------------------------------------------------------------------------------
  set foldenable          " enable folding
  set foldlevelstart=10   " open most folds by default
  set foldnestmax=10      " 10 nested fold max
  set foldmethod=manual   " fold manually
  set foldlevel=1


" StatusLine
" ---------------------------------------------------------------------------------------
  function! CocStatus() abort
    let info = get(g:, 'coc_status', '')
    if empty(info)
      return ''
    else
      return winwidth(0) > 100 ? (info): ''
    endif
  endfunction

  function! CocDiagnostics(kind, sign) abort
    let info = get(b:, 'coc_diagnostic_info', 0)
    if empty(info) || get(info, a:kind, 0) == 0
      return ''
    endif
    return printf('%s %d', a:sign, info[a:kind])
  endfunction

  function! s:statusline_expr()
    let mod = "%{&modified ? '[+] ' : !&modifiable ? '[x] ' : ''}"
    let ro  = "%{&readonly ? '[RO] ' : ''}"
    let ft  = "%{len(&filetype) ? '['.&filetype.'] ' : ''}"
    let fug = "%{exists('g:loaded_fugitive') ? fugitive#statusline() : ''}"
    let sep = ' %= '
    let pos = ' %-12(%l : %c%V%) '
    let pct = ' %P'
    let coc_status = '%{CocStatus()}'
    let coc_warn = '%#WarningMsg#%{CocDiagnostics("warning", "•")}' . '%*'
    let coc_err = '%#WarningMsg#%{CocDiagnostics("error", "•")}' . '%*'
    let diag = coc_warn . coc_err
    return '[%n] %f '.ft.mod.ro.coc_status.diag.' %<'.sep.fug.pos.'%*'.pct
  endfunction
  let &statusline = s:statusline_expr()



" }}}
" =======================================================================================
" MAPPINGS {{{
" =======================================================================================


" leader is now comma
" ---------------------------------------------------------------------------------------
  map , <leader>


" work like * and g*, but do not move the cursor and always set hls
" ---------------------------------------------------------------------------------------
  nnoremap * :let @/ = '\<'.expand('<cword>').'\>'\|set hlsearch<C-M>
  nnoremap g* :let @/ = expand('<cword>')\|set hlsearch<C-M>


" visual mode pressing * or # searches for the current selection
" ---------------------------------------------------------------------------------------
  vnoremap <silent> * :<C-U>
        \let old_reg=getreg('"')<Bar>let old_regtype=getregtype('"')<CR>
        \gvy/<C-R>=&ic?'\c':'\C'<CR><C-R><C-R>=substitute(
        \escape(@", '/\.*$^~['), '\_s\+', '\\_s\\+', 'g')<CR><CR>
        \gVzv:call setreg('"', old_reg, old_regtype)<CR>
  vnoremap <silent> # :<C-U>
        \let old_reg=getreg('"')<Bar>let old_regtype=getregtype('"')<CR>
        \gvy?<C-R>=&ic?'\c':'\C'<CR><C-R><C-R>=substitute(
        \escape(@", '?\.*$^~['), '\_s\+', '\\_s\\+', 'g')<CR><CR>
        \gVzv:call setreg('"', old_reg, old_regtype)<CR>

" do not exit from visual mode when shifting
" ---------------------------------------------------------------------------------------
  vnoremap < <gv
  vnoremap > >gv


" Treat long lines as break lines
" (useful when moving around in them) but when preceded by a count,
" go back to normal and save movement in jumplist lager than 5
" ---------------------------------------------------------------------------------------
  nnoremap <expr> j v:count ? (v:count > 5 ? "m'" . v:count : '') . 'j' : 'gj'
  nnoremap <expr> k v:count ? (v:count > 5 ? "m'" . v:count : '') . 'k' : 'gk'


" turn off search highlight
" ---------------------------------------------------------------------------------------
  nmap <leader><space> :nohlsearch<CR>


" Make arrow keys do something useful
" ---------------------------------------------------------------------------------------
  nnoremap <Left> :vertical resize +2<CR>
  nnoremap <Right> :vertical resize -2<CR>
  nnoremap <Up> :resize -2<CR>
  nnoremap <Down> :resize +2<CR><Paste>


" Buffer navigation
" ---------------------------------------------------------------------------------------
  function! s:buffernavigation(cmd)
    let buf = bufnr()
    execute a:cmd
    while ( &buftype == 'terminal'
          \ || &filetype == 'qf'
          \ || &filetype == 'fugitive'
          \ || &filetype == 'netrw'
          \ || &filetype == 'dirvish')
          \ && bufnr() != buf
      execute a:cmd
    endwhile
  endfunction

  " buffer previous
  nnoremap [b :<c-u>call <SID>buffernavigation('bprevious')<CR>
  " buffer next
  nnoremap ]b :<c-u>call <SID>buffernavigation('bnext')<CR>
  " new empty buffer
  nnoremap <C-b> :enew<CR>
  " conform changes (Yes, No, Cancel) instead of error
  " set confirm
  " close buffer
  nnoremap <leader>bx :bp <BAR> bd #<CR>


" Tab navigations
" ---------------------------------------------------------------------------------------
  " tap previous
  nnoremap [t  :tabprevious<CR>
  " tap next
  nnoremap ]t  :tabnext<CR>
  function! OpenCurrentAsNewTab()
    let l:currentPos = getcurpos()
    tabedit %
    call setpos(".", l:currentPos)
  endfunction
  " new tap with current buffer
  nnoremap <C-t> :call OpenCurrentAsNewTab()<CR>
  " close tap
  nnoremap <leader>tx :tabclose<CR>


" Window navigations
" ---------------------------------------------------------------------------------------
  nmap <C-J> <C-W><C-J>
  nmap <C-K> <C-W><C-K>
  nmap <C-L> <C-W><C-L>
  nmap <C-H> <C-W><C-H>
  set splitbelow
  set splitright

  " remove window
  nmap <C-W>x <C-W>q

  " circular navigation
  " nnoremap <tab>   <c-w>w
  " nnoremap <S-tab> <c-w>W


" yanked text using osc52 and X11
" ---------------------------------------------------------------------------------------
  " copy to attached terminal using the yank(1) script:
  " https://github.com/sunaku/home/blob/master/bin/yank
  function! s:yank(text) abort
    " if in tmux, update environment variable to yank properly
    if !empty($TMUX)
      " if SSH_TTY is set
      if system('tmux show-env SSH_TTY') !~# '^-.*'
        let $SSH_TTY = split(trim(system('tmux show-env SSH_TTY')), '=')[1]
      endif
      " if DISPLAY is set
      if system('tmux show-env DISPLAY') !~# '^-.*'
        let $DISPLAY = split(trim(system('tmux show-env DISPLAY')), '=')[1]
      endif
    endif
    " try osc52 first
    if executable('osc52')
      let escape = system('osc52', a:text)
      if v:shell_error
        echoerr escape
        echo 'Using X11 to copy'
        call setreg('+', a:text)
      endif
    else
      call setreg('+', a:text)
    endif
  endfunction

  function! s:get_from_marker(m_start, m_end)
    " Why is this not a built-in Vim script function?!
    let [line_start, column_start] = getpos(a:m_start)[1:2]
    let [line_end, column_end] = getpos(a:m_end)[1:2]
    let lines = getline(line_start, line_end)
    if len(lines) == 0
      return ''
    endif
    let lines[-1] = lines[-1][: column_end - (&selection == 'inclusive' ? 1 : 2)]
    let lines[0] = lines[0][column_start - 1:]
    return join(lines, "\n")
  endfunction

  function! s:yank_wrapper(type, ...)
    let sel_save = &selection
    let &selection = "inclusive"
    let reg_save = @@

    if a:0  " Invoked from Visual mode
      call s:yank(s:get_from_marker("'<", "'>'"))
    elseif a:type == 'line'
      call s:yank(s:get_from_marker("'[", "']'"))
    else
      call s:yank(s:get_from_marker("`[", "`]'"))
    endif

    let &selection = sel_save
    let @@ = reg_save
  endfunction

  nmap <silent> <leader>y :set opfunc=<SID>yank_wrapper<CR>g@
  vmap <silent> <leader>y :<C-U>call <SID>yank_wrapper(visualmode(), 1)<CR>


" Terminal inside of vim
" steal from https://github.com/vimlab/split-term.vim
" ---------------------------------------------------------------------------------------
  function! s:openBuffer(count, vertical)
    let cmd = a:vertical ? 'vnew' : 'new'
    let cmd = a:count ? a:count . cmd : cmd
    exe cmd
  endfunction
  " steal https://github.com/junegunn/fzf.vim/issues/821#issuecomment-581273191
  function! s:openFloatBuffer()
    " Configuration
    let height = float2nr((&lines - 2) * 0.6)
    let row = float2nr((&lines - height) / 2)
    let width = float2nr(&columns * 0.8)
    let col = float2nr((&columns - width) / 2)
    let top = "╭" . repeat("─", width + 2) . "╮"
    let mid = "│" . repeat(" ", width + 2) . "│"
    let bot = "╰" . repeat("─", width + 2) . "╯"
    let border = [top] + repeat([mid], height) + [bot]

    " Border Window
    let border_opts = {
          \ 'row': row - 1,
          \ 'col': col - 2,
          \ 'width': width + 4,
          \ 'height': height + 2,
          \ }
    " Terminal Window
    let opts = {
          \ 'row': row,
          \ 'col': col,
          \ 'width': width,
          \ 'height': height,
          \ }

    if has ('nvim')
      let border_opts = extend({'is_frame': 1,}, border_opts)
      let frame = s:create_float('Todo', border_opts)
      call nvim_buf_set_lines(frame, 0, -1, v:true, border)
      call s:create_float('Normal', opts)
    else
      let opts = extend({'is_frame': 1,}, border_opts)
      let frame = s:create_popup_window('Todo', border_opts)
      call setbufline(frame, 1, border)
      call s:create_popup_window('Normal', opts)
    endif
  endfunction
  function s:create_float(hl, opts) abort
    if has_key(a:opts, 'is_frame')
      unlet a:opts.is_frame
      let is_frame = "true"
    else
      let is_frame = "false"
    endif

    let buf = nvim_create_buf(v:false, v:true)
    let opts = extend({'relative': 'editor', 'style': 'minimal'}, a:opts)
    let win = nvim_open_win(buf, v:true, opts)
    call setwinvar(win, '&winhighlight', 'NormalFloat:'..a:hl)
    if l:is_frame == "true"
      " Close border window when terminal window close
      exe 'autocmd TermClose * ++once :bd! | call nvim_win_close('..l:win..', v:true)'
    endif
    return buf
  endfunction
  function s:create_popup_window(hl, opts) abort
    if has_key(a:opts, 'is_frame')
      let id = popup_create('', #{
            \ line: a:opts.line,
            \ col: a:opts.col,
            \ minwidth: a:opts.width,
            \ minheight: a:opts.height,
            \ zindex: 50,
            \ })
      call setwinvar(id, '&wincolor', a:hl)
      exe 'au BufWipeout * ++once call popup_close('..id..')'
      return winbufnr(id)
    else
      let buf = term_start(&shell, #{hidden: 1})
      call popup_create(buf, #{
            \ line: a:opts.line,
            \ col: a:opts.col,
            \ minwidth: a:opts.width,
            \ minheight: a:opts.height,
            \ zindex: 51,
            \ })
      exe 'au BufWipeout * ++once bw! '..buf
    endif
  endfunction
  function! s:openTerm(args, count, direction)
    let params = split(a:args)
    let direction = a:direction

    if a:direction == 3
      call s:openFloatBuffer()
    else
      call s:openBuffer(a:count, direction)
    endif

    exe 'terminal' a:args
    exe 'startinsert'
  endfunction
  command! -count -nargs=* TermHorizontal call s:openTerm(<q-args>, <count>, 0)
  command! -count -nargs=* TermVertical call s:openTerm(<q-args>, <count>, 1)
  command! -count -nargs=* TermFloat call s:openTerm(<q-args>, <count>, 3)
  if has('nvim-0.4') || has('patch-8.2.191')
    nnoremap <leader>R :TermFloat<CR>
  else
    nnoremap <leader>R :TermHorizontal<CR>
  endif

  tnoremap <Esc> <C-\><C-n>
  if has('nvim')
    augroup terminal_options
      autocmd!
      autocmd TermOpen term://*fzf* tnoremap <buffer> <Esc> <Esc>
      autocmd TermOpen * setlocal nonumber norelativenumber
    augroup END
  endif


" Coneallevel control
" ---------------------------------------------------------------------------------------
  function! ToggleConcealLevel()
    if &conceallevel == 0
      setlocal conceallevel=2
    else
      setlocal conceallevel=0
    endif
  endfunction
  nnoremap <silent> yoa :call ToggleConcealLevel()<CR>


" Change register
" ---------------------------------------------------------------------------------------
  function! ChangeReg() abort
    let r = nr2char(getchar())
    if r =~# '[a-zA-Z0-9"@\-:.%#=*"~_/]'
      call feedkeys("q:ilet @" . r . " = \<C-r>\<C-r>=string(@" . r . ")\<CR>\<ESC>", 'n')
    endif
  endfunction
  nnoremap <silent> rc :call ChangeReg()<CR>


" Move visual block
" ---------------------------------------------------------------------------------------
  vnoremap J :m '>+1<CR>gv=gv
  vnoremap K :m '<-2<CR>gv=gv


" Redirect the output of a Vim or external command into a scratch buffer
" https://gist.github.com/romainl/eae0a260ab9c135390c30cd370c20cd7
" ---------------------------------------------------------------------------------------
  function! Redir(cmd)
    for win in range(1, winnr('$'))
      if getwinvar(win, 'scratch')
        execute win . 'windo close'
      endif
    endfor
    if a:cmd =~ '^!'
      if a:cmd =~' %'
        let cmd = substitute(a:cmd, ' %', ' ' . expand('%:p'), '')
      else
        let cmd = a:cmd
      endif
      let output = system(matchstr(cmd, '^!\zs.*'))
    else
      redir => output
      execute a:cmd
      redir END
    endif
    vnew
    let w:scratch = 1
    setlocal buftype=nofile bufhidden=wipe nobuflisted noswapfile
    call setline(1, split(output, "\n"))
  endfunction

  command! -nargs=1 -complete=command Redir silent call Redir(<q-args>)
  " Usage:
  " 	:Redir %w !python ..... show the full output of command ':%w !python' in a scratch window
  " 	:Redir .w !bash ....... show the full output of command ':.w !bash' in a scratch window
  " 	:Redir hi ............. show the full output of command ':hi' in a scratch window
  " 	:Redir !ls -al ........ show the full output of command ':!ls -al' in a scratch window


" Improve grep
" ---------------------------------------------------------------------------------------
  function! Grep(...)
    " neovim v0.4.4 has no expandcmd()
    let l:expands = []
    for elem in a:000
      let l:expands += ['"' . expand(elem) . '"']
    endfor
    return system(join([&grepprg] + l:expands))
  endfunction
  command! -nargs=+ -complete=file_in_path -bar Grep  cgetexpr Grep(<f-args>)
  command! -nargs=+ -complete=file_in_path -bar LGrep lgetexpr Grep(<f-args>)
  " Open the location/quickfix window automatically if there are valid entries in the list
  augroup quickfix
    autocmd!
    autocmd QuickFixCmdPost cgetexpr cwindow
    autocmd QuickFixCmdPost lgetexpr lwindow
  augroup END
  cnoreabbrev <expr> grep (getcmdtype() ==# ':' && getcmdline() ==# 'grep') ? 'Grep' : 'grep'
  cnoreabbrev <expr> lgrep (getcmdtype() ==# ':' && getcmdline() ==# 'lgrep') ? 'LGrep' : 'lgrep'


" yanking
" ---------------------------------------------------------------------------------------
  " reselect the yanked region with `gb`
  nnoremap <expr> gb '`[' . strpart(getregtype(), 0, 1) . '`]'
  " paste without yanking in visual mode with `P`
  xnoremap <expr> P '"_d"'.v:register.'P'


" Output the current syntax group
" ---------------------------------------------------------------------------------------
  nnoremap <leader>hg :echo "hi<" . synIDattr(synID(line("."),col("."),1),"name") . '> trans<'
        \ . synIDattr(synID(line("."),col("."),0),"name") . "> lo<"
        \ . synIDattr(synIDtrans(synID(line("."),col("."),1)),"name") . ">"<cr>


" Readline-style key bindings in command-line (excerpt from rsi.vim)
" ---------------------------------------------------------------------------------------
  cnoremap <C-A> <Home>
  cnoremap <C-B> <Left>
  cnoremap <M-b> <S-Left>
  cnoremap <M-f> <S-Right>


" shebang
" ---------------------------------------------------------------------------------------
  inoreabbrev <expr> #!! "#!/usr/bin/env" . (empty(&filetype) ? '' : ' '.&filetype)


" }}}
" =======================================================================================
" FUNCTIONS {{{
" =======================================================================================


" neovim python support
" ---------------------------------------------------------------------------------------
  if has('nvim')
    let g:python_host_prog = system("echo -n $HOME/.virtualenvs/neovim2/bin/python")
    let g:python3_host_prog = system("echo -n $HOME/.virtualenvs/neovim3/bin/python")
  endif


" Remove trailing whitespaces on save
" ---------------------------------------------------------------------------------------
  function! StripTrailingWhitespaces()
    let l = line(".")
    let c = col(".")
    %s/\s\+$//e
    call cursor(l, c)
  endfunction
  autocmd FileType c,cpp,java,javascript,html,ruby,python,pandoc
        \ autocmd BufWritePre <buffer> :call StripTrailingWhitespaces()


" Disable few things on file larger than 250mb
" ---------------------------------------------------------------------------------------
  let g:LargeFile = 1024 * 1024 * 250
  augroup LargeFile
    autocmd BufReadPre * let f=getfsize(expand("<afile>")) | if f > g:LargeFile || f == -2 | call LargeFile() | endif
  augroup END

  function! LargeFile()
    " no syntax highlighting etc
    " set eventignore+=FileType
    " save memory when other file is viewed
    setlocal bufhidden=unload
    " is read-only (write with :w new_filename)
    setlocal buftype=nowrite
    " no undo possible
    setlocal undolevels=-1
    " display message
    autocmd VimEnter *  echo 'The file is larger than ' . (g:LargeFile / 1024 / 1024) . ' MB, so some options are changed (see .vimrc for details).'
  endfunction


" Vim jump to the last position when reopening a file
" ---------------------------------------------------------------------------------------
  autocmd BufReadPost * if line("'\"") > 1 && line("'\"") <= line("$") | exe "normal! g'\"" | endif


" auto marker
" ---------------------------------------------------------------------------------------
  augroup contextswitch
    autocmd!
    autocmd BufLeave *.py           normal! mP
    autocmd BufLeave *.yaml,*.yml   normal! mY
    autocmd BufLeave *.md           normal! mM
  augroup END


" copy the current file's full absolute path.
" ---------------------------------------------------------------------------------------
  command! CopyFilePath let @+ = expand(has('win32') ? '%:p:gs?/?\\?' : '%:p')


" copy the directory where current file is in.
" ---------------------------------------------------------------------------------------
  command! CopyFileDir let @+ = expand(has('win32') ? '%:p:h:gs?/?\\?' : '%:p:h')


" go to current file directory
" ---------------------------------------------------------------------------------------
  function! Cd()
    if !empty($TMUX)
      call system("tmux new-window -c " . expand('%:p:h'))
    else
      echo "You are not in tmux session. Copy directory into clipboard instead."
      execute 'CopyFileDir'
    endif
  endfunction
  command! Cd call Cd()


" Custom location for quickfix and loclist
" ---------------------------------------------------------------------------------------
  function! CustomiseLocation()
    " if loclist, put it below the current window
    if getwininfo(win_getid())[0]['loclist'] == 1
    " if quickfix, put it bellow the whole window
    elseif getwininfo(win_getid())[0]['quickfix'] == 1
      wincmd J
    endif
  endfunction
  autocmd FileType qf call CustomiseLocation()


" }}}
" =======================================================================================
" PLUGINS SETTINGS {{{
" =======================================================================================


" tpope/vim-fugitive
" ---------------------------------------------------------------------------------------
  if has_key(g:plugs, 'vim-fugitive')
    nnoremap <leader>gs :Git<CR>
    nnoremap <leader>gd :Gdiff<CR>
  endif


" rhysd/git-messenger.vim
" ---------------------------------------------------------------------------------------
  if has_key(g:plugs, 'git-messenger.vim')
    let g:git_messenger_no_default_mappings = v:true
    let g:git_messenger_include_diff = "current"
    nmap <leader>gm <Plug>(git-messenger)

    function! s:setup_git_messenger_popup() abort
      " set go back/forward history to <C-o>/<C-i>
      nmap <buffer><C-o> o
      nmap <buffer><C-i> O
    endfunction
    autocmd FileType gitmessengerpopup call <SID>setup_git_messenger_popup()
  endif


" preservim/nerdtree
" ---------------------------------------------------------------------------------------
  if has_key(g:plugs, 'nerdtree')
    nmap <leader>N :NERDTreeToggle<CR>
  endif

" scrooloose/nerdcommenter
" ---------------------------------------------------------------------------------------
  if has_key(g:plugs, 'nerdcommenter')
    " Add spaces after comment delimiters by default
    let g:NERDSpaceDelims = 1
    " Use compact syntax for prettified multi-line comments
    let g:NERDCompactSexyComs = 1
    " Align line-wise comment delimiters flush left instead of following code indentation
    let g:NERDDefaultAlign = 'left'
    " Set a language to use its alternate delimiters by default
    let g:NERDAltDelims_java = 1
    " Add your own custom formats or override the defaults
    let g:NERDCustomDelimiters = { 'c': { 'left': '/**','right': '*/' } }
    " Allow commenting and inverting empty lines (useful when commenting a region)
    let g:NERDCommentEmptyLines = 1
    " Enable trimming of trailing whitespace when uncommenting
    let g:NERDTrimTrailingWhitespace = 1
    " Enable NERDCommenterToggle to check all selected lines is commented or not
    let g:NERDToggleCheckAllLines = 1
  endif


" junegunn/fzf.vim
" ---------------------------------------------------------------------------------------
  if has_key(g:plugs, 'fzf.vim')
    nnoremap <leader>F :Files<CR>
    nnoremap <leader>B :Buffers<CR>
    nnoremap <leader>P :ProjectFiles<CR>

    " Search project root
    function! s:find_git_root()
      return system('git rev-parse --show-toplevel 2> /dev/null')[:-2]
    endfunction
    command! ProjectFiles execute 'Files' s:find_git_root()

    " Customize fzf colors to match your color scheme
    let g:fzf_colors =
          \ {
          \ 'fg':      ['fg', 'Normal'],
          \ 'bg':      ['bg', 'Normal'],
          \ 'hl':      ['fg', 'Comment'],
          \ 'fg+':     ['fg', 'CursorLine', 'CursorColumn', 'Normal'],
          \ 'bg+':     ['bg', 'CursorLine', 'CursorColumn'],
          \ 'hl+':     ['fg', 'Statement'],
          \ 'info':    ['fg', 'PreProc'],
          \ 'border':  ['fg', 'Ignore'],
          \ 'prompt':  ['fg', 'Conditional'],
          \ 'pointer': ['fg', 'Exception'],
          \ 'marker':  ['fg', 'Keyword'],
          \ 'spinner': ['fg', 'Label'],
          \ 'header':  ['fg', 'Comment'] }

    " Rg: start fzf
    " Rg!: start fzf with preview window
    command! -bang -nargs=* Rg
     \ call fzf#vim#grep(
     \   'rg --column --line-number --no-heading --color=always --smart-case '.shellescape(<q-args>), 1,
     \   <bang>0 ? fzf#vim#with_preview('up:60%')
     \           : fzf#vim#with_preview('right:50%:hidden', '?'),
     \   <bang>0)
  endif


" christoomey/vim-tmux-navigator
" ---------------------------------------------------------------------------------------
  if has_key(g:plugs, 'vim-tmux-navigator')
    let g:tmux_navigator_no_mappings = 1

    nnoremap <silent> <C-h> :TmuxNavigateLeft<cr>
    nnoremap <silent> <C-j> :TmuxNavigateDown<cr>
    nnoremap <silent> <C-k> :TmuxNavigateUp<cr>
    nnoremap <silent> <C-l> :TmuxNavigateRight<cr>
    nnoremap <silent> <C-\> :TmuxNavigatePrevious<cr>
    " Disable tmux navigator when zooming the Vim pane
    let g:tmux_navigator_disable_when_zoomed = 1
  endif


" junegunn/vim-easy-align
" ---------------------------------------------------------------------------------------
  if has_key(g:plugs, 'vim-easy-align')
    " Start interactive EasyAlign in visual mode (e.g. vipga)
    xmap ga <Plug>(EasyAlign)
    " Start interactive EasyAlign for a motion/text object (e.g. gaip)
    nmap ga <Plug>(EasyAlign)
  endif


" junegunn/gv.vim
" ---------------------------------------------------------------------------------------
  if has_key(g:plugs, 'gv.vim')
    function! s:gv_expand()
      let line = getline('.')
      GV --name-status
      call search('\V'.line, 'c')
      normal! zz
    endfunction
    autocmd! FileType GV nnoremap <buffer> <silent> + :call <sid>gv_expand()<cr>
  endif

" mhinz/vim-startify
" ---------------------------------------------------------------------------------------
  if has_key(g:plugs, 'vim-startify')
    nnoremap <leader>S :Startify<CR>

    let s:dotfiles_path = fnamemodify(resolve($MYVIMRC), ':h:h')

    let g:startify_bookmarks = [
          \ { 'a': $MYVIMRC },
          \ { 's': s:dotfiles_path . '/tmux/tmux.conf' },
          \ { 'z': s:dotfiles_path . '/zsh/zshrc' },
          \ { 'x': s:dotfiles_path . '/zsh/zpreztorc' },
          \ { 'c': s:dotfiles_path . '/config/fish/config.fish' },
          \]
    let g:startify_change_to_dir = 0
  endif


" unblevable/quick-scope
" ---------------------------------------------------------------------------------------
  if has_key(g:plugs, 'quick-scope')
    let g:qs_highlight_on_keys = ['f', 'F', 't', 'T']
    augroup qs_colors
      autocmd!
      autocmd ColorScheme * highlight QuickScopePrimary guifg='#afff5f' gui=underline ctermfg=155 cterm=underline
      autocmd ColorScheme * highlight QuickScopeSecondary guifg='#5fffff' gui=underline ctermfg=81 cterm=underline
    augroup END
    " need to set colorscheme after autocmd is defined
    execute 'colorscheme ' .  get(g:, 'colors_name', 'default')
  endif


" tpope/vim-unimpaired
" ---------------------------------------------------------------------------------------
  if has_key(g:plugs, 'vim-unimpaired')
    let g:nremap = {"[t": "", "]t": "", "[T": "", "]T": ""}
  endif


" Yggdroot/indentLine
" ---------------------------------------------------------------------------------------
  if has_key(g:plugs, 'indentLine')
    let g:indentLine_enabled = 1
    let g:indentLine_faster = 1
    " let g:indentLine_setColors = 0
    let g:indentLine_defaultGroup = 'SpecialKey'
    " let g:indentLine_setConceal = 0
    " let g:indentLine_char = '┊'
    " let g:indentLine_char_list = ['|', '¦', '┆', '┊']
  endif


" neoclide/coc.nvim
" ---------------------------------------------------------------------------------------
  if has_key(g:plugs, 'coc.nvim')
    let g:coc_global_extensions = [
          \ 'coc-emoji', 'coc-snippets', 'coc-highlight', 'coc-json', 'coc-tsserver',
          \ 'coc-html', 'coc-css', 'coc-yaml', 'coc-vimtex', 'coc-pyright', 'coc-go',
          \ 'coc-sh', 'coc-vimlsp',
          \ ]

    if executable('ccls')
      call coc#config('languageserver.ccls', {
            \ 'command': 'ccls',
            \ 'filetypes': ['c', 'cpp', 'objc', 'objcpp'],
            \ 'rootPatterns': ['.ccls', 'compile_commands.json', '.vim/', '.git/', '.hg/'],
            \ 'initializationOptions': {
            \   'cache': {
            \   'directory': '/tmp/ccls'
            \   }
            \ }
            \})
    endif

    " Use tab for trigger completion with characters ahead and navigate.
    " NOTE: Use command ':verbose imap <tab>' to make sure tab is not mapped by
    " other plugin before putting this into your config.
    inoremap <silent><expr> <TAB>
          \ pumvisible() ? "\<C-n>" :
          \ <SID>check_back_space() ? "\<TAB>" :
          \ coc#refresh()
    inoremap <expr><S-TAB> pumvisible() ? "\<C-p>" : "\<C-h>"

    function! s:check_back_space() abort
      let col = col('.') - 1
      return !col || getline('.')[col - 1]  =~# '\s'
    endfunction

    " Use <c-j> to trigger completion.
    inoremap <silent><expr> <c-j> coc#refresh()

    " Use <C-l> for trigger snippet expand.
    imap <C-l> <Plug>(coc-snippets-expand)

    " Use <C-j> for select text for visual placeholder of snippet.
    vmap <C-j> <Plug>(coc-snippets-select)

    " Use <C-j> for jump to next placeholder, it's default of coc.nvim
    let g:coc_snippet_next = '<c-j>'

    " Use <C-k> for jump to previous placeholder, it's default of coc.nvim
    let g:coc_snippet_prev = '<c-k>'

    " " Use `[d` and `]d` to navigate diagnostics
    " " Use `:CocDiagnostics` to get all diagnostics of current buffer in location list.
    " nmap <silent> [d <Plug>(coc-diagnostic-prev)
    " nmap <silent> ]d <Plug>(coc-diagnostic-next)

    " GoTo code navigation.
    nmap <silent> gd <Plug>(coc-definition)
    nmap <silent> gy <Plug>(coc-type-definition)
    nmap <silent> gc <Plug>(coc-implementation)
    nmap <silent> gr <Plug>(coc-references)

    function! SplitIfNotOpen(...)
      let fname = a:1
      let call = ''
      if a:0 == 2
        let fname = a:2
        let call = a:1
      endif
      let bufnum=bufnr(expand(fname))
      let winnum=bufwinnr(bufnum)
      if winnum != -1
        " Jump to existing split
        exe winnum . "wincmd w"
      else
        " Make new split as usual
        exe "vsplit " . fname
      endif
      " Execute the cursor movement command
      exe call
    endfunction
    command! -nargs=+ CocSplitIfNotOpen :call SplitIfNotOpen(<f-args>)

    " Use K to show documentation in preview window.
    nnoremap <silent> K :call <SID>show_documentation()<CR>

    function! s:show_documentation()
      if (index(['vim','help'], &filetype) >= 0)
        execute 'h '.expand('<cword>')
      else
        call CocAction('doHover')
      endif
    endfunction

    " Highlight the symbol and its references when holding the cursor.
    autocmd CursorHold * silent call CocActionAsync('highlight')

    " Symbol renaming.
    nmap <leader>rn <Plug>(coc-rename)

    " Formatting selected code.
    xmap <leader>f  <Plug>(coc-format-selected)
    nmap <leader>f  <Plug>(coc-format-selected)

    " Add `:Format` command to format current buffer.
    command! -nargs=0 Format :call CocAction('format')

    " Add `:OR` command for organize imports of the current buffer.
    command! -nargs=0 OR     :call CocAction('runCommand', 'editor.action.organizeImport')

    " Add `:Fold` command to fold current buffer.
    command! -nargs=? Fold   :call CocAction('fold', <f-args>)

  endif

  echo expand('<abuf>')


" fatih/vim-go
" ---------------------------------------------------------------------------------------
  if has_key(g:plugs, 'vim-go')
    " disable mapping
    let g:go_def_mapping_enabled = 0
    let g:go_doc_keywordprg_enabled = 0
    " disable completion
    let g:go_code_completion_enabled = 0
    " diable all syntax highlight
    if !has_key(g:plugs, 'nvim-treesitter')
      let g:go_highlight_fields = 1
      let g:go_highlight_structs = 1
      let g:go_highlight_methods = 1
      let g:go_highlight_functions = 1
      let g:go_highlight_operators = 1
      let g:go_highlight_build_constraints = 1
      let g:go_highlight_function_parameters = 1
      let g:go_highlight_function_calls = 1
      let g:go_highlight_format_strings = 1
    endif
  endif


" liuchengxu/vista.vim
" ---------------------------------------------------------------------------------------
  if has_key(g:plugs, 'vista.vim')
    nmap <leader>T :Vista!!<CR>

    let g:vista_icon_indent = ["▸ ", ""]

    let g:vista#renderer#enable_icon = 1
    let g:vista#renderer#icons = {
          \   "function": "\uf794",
          \   "variable": "\uf71b",
          \  }

    let g:vista_default_executive = 'ctags'

    let g:vista_executive_for = {
          \ 'vim': 'coc',
          \ 'sh': 'coc',
          \ 'python': 'coc',
          \ 'yaml': 'coc',
          \ 'tex': 'coc',
          \ 'go': 'coc',
          \ }
  endif


" iamcco/markdown-preview.nvim
" ---------------------------------------------------------------------------------------
  if has_key(g:plugs, 'markdown-preview.nvim')
    let g:mkdp_echo_preview_url = 1
    let g:mkdp_open_to_the_world = 1
    let g:mkdp_port = '40100'

    function! g:OpenBrowser(url)
      if has('mac')
        silent exe 'silent !open -na "Google Chrome" --args --incognito --new-window ' . a:url
      else
        call s:yank(a:url)
        echo 'url copied to clipboard'
      endif
    endfunction
    let g:mkdp_browserfunc = 'g:OpenBrowser'
  endif


" liuchengxu/vim-which-key
" ---------------------------------------------------------------------------------------
  if has_key(g:plugs, 'vim-which-key')
    nnoremap <silent> <leader> :<c-u>WhichKey '\'<CR>
    highlight default link WhichKeyFloating CocFloating
  endif


" tpope/vim-vinegar
" ---------------------------------------------------------------------------------------
  " https://github.com/tpope/vim-vinegar/issues/13#issuecomment-489440040
  let g:netrw_fastbrowse = 0


" kkoomen/vim-doge
" ---------------------------------------------------------------------------------------
  let g:doge_mapping = '<Leader>D'
  let g:doge_doc_standard_python = 'google'


" AndrewRadev/splitjoin.vim
" ---------------------------------------------------------------------------------------
  let g:splitjoin_python_brackets_on_separate_lines = 1


" nvim-treesitter/nvim-treesitter
" ---------------------------------------------------------------------------------------
  if has_key(g:plugs, 'nvim-treesitter')
    lua <<EOF
require'nvim-treesitter.configs'.setup {
  ensure_installed = "maintained",
  highlight = {
    enable = true,
    use_languagetree = false,
    disable = { "bash", },
  },
}
EOF
  endif

" }}}
