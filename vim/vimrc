" VIM-PLUG {{{

    " {{{ vim-plug
        if has('nvim')
            " automatic installation (for Neovim: ~/.local/share/nvim/site/autoload/plug.vim)
            if empty(glob('~/.local/share/nvim/site/autoload/plug.vim'))
                silent !curl -flo ~/.local/share/nvim/site/autoload/plug.vim --create-dirs
                            \ https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim
                autocmd vimenter * pluginstall --sync | source $myvimrc
            endif
            " Specify a directory for plugins (for Neovim: ~/.local/share/nvim/plugged)
            call plug#begin('~/.local/share/nvim/plugged')
            " Make sure you use single quotes
        else
            " automatic installation (for vim: ~/.vim/autoload/plug.vim)
            if empty(glob('~/.vim/autoload/plug.vim'))
                silent !curl -flo ~/.vim/autoload/plug.vim --create-dirs
                            \ https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim
                autocmd vimenter * pluginstall --sync | source $myvimrc
            endif
            " Specify a directory for plugins (for vim: ~/.vim/plugged)
            call plug#begin('~/.vim/plugged')
            " Make sure you use single quotes
        endif
    " }}}

    " Plugins for pretty vim {{{
        "  scheme ============================================
        " Plug 'flazz/vim-colorschemes'
        " Plug 'chriskempson/base16-vim'
        " Plug 'morhetz/gruvbox'
        " Plug 'w0ng/vim-hybrid'
        " Plug 'joshdick/onedark.vim'
        " Plug 'junegunn/seoul256.vim'
        " Plug 'dracula/vim', { 'as': 'dracula' }
        Plug 'ryanoasis/vim-devicons'
        Plug 'sainnhe/edge'
        " =========================================================

    " }}}

    " Plugins for Language specific (syntax, completion, etc.) {{{
        Plug 'dag/vim-fish',                  { 'for': 'fish' }      " fish script
        Plug 'Vimjas/vim-python-pep8-indent', { 'for': 'python' }
        Plug 'plasticboy/vim-markdown',       { 'for': 'markdown' }
        Plug 'chrisbra/csv.vim',              { 'for': 'csv' }
        Plug 'lervag/vimtex',                 { 'for': 'tex' }
        Plug 'fatih/vim-go',                  { 'do': ':GoUpdateBinaries', 'for': 'go' }
        Plug 'Shougo/neco-vim'                                       " vimrc completion source for coc
        Plug 'neoclide/coc-neco'                                     " vimrc completion source for coc
        Plug 'neoclide/coc.nvim',             {'branch': 'release'}
        if has('nvim')
            Plug 'numirias/semshi',           { 'do': ':UpdateRemotePlugins', 'for': 'python' } " python color scheme
        endif
    " }}}

    " Plugins for Convenient coding {{{
        Plug 'Shougo/context_filetype.vim'                                   " provides functions to find fenced code blocks and their filetype
        " Plug 'sirver/ultisnips'                                            " snippet engin -> coc.nvim
        Plug 'honza/vim-snippets'                                            " snippet source
        Plug 'justinmk/vim-dirvish'                                          " faster filebrowser
        " Plug 'tpope/vim-vinegar'                                           " netrw filebrowser -> vim-dirvish
        Plug 'liuchengxu/vista.vim'                                          " alternative of tagbar
        Plug 'machakann/vim-sandwich'                                        " alternative of vim-surround
        Plug 'scrooloose/nerdcommenter'                                      " make comment easyier
        Plug 'Yggdroot/indentLine'                                           " indent indicator
        Plug 'jiangmiao/auto-pairs'                                          " insert and delete pairs automaticcaly
        Plug 'christoomey/vim-tmux-navigator'                                " seamlessly move between vim splits and tmux panes
        Plug 'tpope/vim-repeat'
        Plug 'tpope/vim-fugitive'                                            " git command in vim
        Plug 'tpope/vim-unimpaired'
        Plug 'tpope/vim-obsession'
        Plug 'tpope/vim-eunuch'
        Plug 'tpope/vim-abolish'
        Plug 'airblade/vim-gitgutter'
        " Plug 'mhinz/vim-signify'
        Plug 'kshenoy/vim-signature'                                         " place, toggle and display marks
        Plug 'junegunn/vim-easy-align', { 'on': '<Plug>(EasyAlign)' }
        Plug 'kana/vim-textobj-user'
        Plug 'michaeljsmith/vim-indent-object'
        Plug 'idbrii/textobj-word-column.vim'
        Plug 'junegunn/gv.vim', { 'on': ['GV', 'GV!'] }
        Plug 'unblevable/quick-scope'
        " Plug 'dhruvasagar/vim-table-mode'                                  " easy table edit
        " Plug 'RRethy/vim-illuminate'                                       " highlight current cursor word -> coc.nvim
        Plug 'junegunn/vim-peekaboo'                                         " show register contents
        " Plug 'AndrewRadev/splitjoin.vim'                                   " switching between one-liner and multiliner
        Plug 'liuchengxu/vim-which-key', { 'on': ['WhichKey', 'WhichKey!'] } " help for leader
        Plug 'RRethy/vim-hexokinase', { 'do': 'make hexokinase' }            " color
        if has('nvim')
            set inccommand=nosplit
        else
            Plug 'markonm/traces.vim'
        endif
    " }}}

    " Plugins for etc. {{{
        Plug 'itchyny/lightline.vim'                            " status line
        Plug 'mgee/lightline-bufferline'                        " status line += buffer
        Plug 'niklaas/lightline-gitdiff'                        " status line += git diff
        Plug 'junegunn/fzf', { 'do': { -> fzf#install() } }     " fuzzy finder
        Plug 'junegunn/fzf.vim'                                 " fuzzy finder for vim
        " Plug 'junegunn/goyo.vim', { 'on': ['Goyo', 'Goyo!'] } " simplify
        Plug 'metakirby5/codi.vim', { 'on': ['Codi'] }
        Plug 'mhinz/vim-startify'                               " fancy startup screen
        Plug 'wellle/tmux-complete.vim'                         " add tmux complete
        " Plug 'TaDaa/vimade'
        Plug 'iamcco/markdown-preview.nvim', { 'do': { -> mkdp#util#install() }, 'for': ['markdown', 'vim-plug'] }
        " Plug 'tmux-plugins/vim-tmux-focus-events'
        " Plug 'jpalardy/vim-slime'
        Plug 'lambdalisue/suda.vim'
        " Plug 'psliwka/vim-smoothie'
    " }}}

    " Initialize plugin system {{{
        call plug#end()
    " }}}

" }}}



" BASIC SETTINGS {{{

    " General {{{
        filetype plugin indent on             " Enable filetype plugins
        set autoread                          " Set to auto read when a file is changed from the outside

        set nocompatible                      " do not compatible to original vi
        set wrap
        set nowrapscan                        " do not go back to the first of the line when it reaches at the end of the line
        set nobackup                          " do not create backup file
        set noswapfile                        " do not create swap file
        set visualbell                        " visualbell on
        set fencs=ucs-bom,utf-8,euc-kr.latin1 " hangle goes euc-kr, unicode goes unicode
        set fileencoding=utf-8                " file saving encoding
        set tenc=utf-8                        " terminal encoding
        set backspace=eol,start,indent        " go to earlier line where the cursor is positioned at end of the line, start of the line and indent
        set hidden                            " unsaved changes in buffer is hidden not quit
        set history=1000                      " remember more commands and search history
        set undofile                          " Maintain undo history between sessions
        set undolevels=1000                   " use many muchos levels of undo
        set undodir=~/.vim/undodir
        set laststatus=2                      " status bar is always on
                                              " set statusline=\ %<%l:%v\ [%P]%=%a\ %h%m%r\ %F\
        set showtabline=2                     " tab bar is always on
        set signcolumn=yes                    " always draw the sign column
        set linebreak
        set colorcolumn=90                    " color column to limit coding length
        set pastetoggle=<F2>                  " when in insert mode, press <F2> to go to
                                              " pasete mode, where you can paste mass data
                                              " that won't be autoindent
        set scrolloff=5                       " When scrolling, keep cursor 5 lines away from screen border
        set cmdheight=2                       " Give more space for displaying messages.
        set updatetime=300                    " Having longer updatetime (default is 4000 ms = 4 s) leads to noticeable
                                              " delays and poor user experience.
        set shortmess+=c                      " Don't pass messages to ins-completion-menu.

        " Always show the signcolumn, otherwise it would shift the text each time
        " diagnostics appear/become resolved.
        if has("patch-8.1.1564")
            " Recently vim can merge signcolumn and number column into one
            set signcolumn=number
        else
            set signcolumn=yes
        endif


        set list                                                    " show unvisible characters
        set listchars=tab:»\ ,nbsp:␣,trail:·,extends:>,precedes:<   " set unvisible characters
        set showbreak=↪\                                            " set breakindent


        " visual autocomplete for command menu
        set wildmenu
        set wildmode=full
        " set wildmode=list:longest,full
        " Setting up ignores
        set wildignore+=*/tmp/*,*.so,*.pyc,*.png,*.jpg,*.gif,*.jpeg,*.ico,*.pdf
        set wildignore+=*.wav,*.mp4,*.mp3
        set wildignore+=*.o,*.out,*.obj,.git,*.rbc,*.rbo,*.class,.svn,*.gem
        set wildignore+=*.zip,*.tar.gz,*.tar.bz2,*.rar,*.tar.xz
        set wildignore+=*/vendor/gems/*,*/vendor/cache/*,*/.bundle/*,*/.sass-cache/*
        set wildignore+=*.swp,*~,._*
        set wildignore+=_pycache_,.DS_Store,.vscode,.localized

        autocmd VimResized * wincmd =     " Resize panes whenever containing window resized.

        " if file has no extention, set it conf
        au BufNewFile,BufRead * if &ft == '' | set ft=conf | endif
        " autocmd BufNewFile,BufRead * if expand('%:t') !~ '\.' | set syntax=conf | endif

        " diff: ignore whitespaces
        " https://www.micahsmith.com/blog/2019/11/fixing-vim-invalid-argument-diffopt-iwhite/
        if ! has('nvim')
            set diffopt-=internal
            set diffopt+=iwhite
        endif

        " only higlight the first 500 characters of each line to improve
        " performance for long line
        " set synmaxcol=500
    " }}}

    " Color scheme {{{
        "Use 24-bit (true-color) mode in Vim/Neovim when outside tmux.
        "If you're using tmux version 2.2 or later, you can remove the outermost $TMUX check and use tmux's 24-bit color support
        "(see < http://sunaku.github.io/tmux-23bit-color.html#usage > for more information.)
        " if (empty($TMUX))
        "     if (has("nvim"))
        "         "For Neovim 0.1.3 and 0.1.4 < https://github.com/neovim/neovim/pull/2198 >
        "         let $NVIM_TUI_ENABLE_TRUE_COLOR=1
        "     endif
        "     "For Neovim > 0.1.5 and Vim > patch 7.4.1799 < https://github.com/vim/vim/commit/61be73bb0f965a895bfb064ea3e55476ac175162 >
        "     "Based on Vim patch 7.4.1770 (`guicolors` option) < https://github.com/vim/vim/commit/8a633e3427b47286869aa4b96f2bfc1fe65b25cd >
        "     " < https://github.com/neovim/neovim/wiki/Following-HEAD#20160511 >
        "     if (has("termguicolors"))
        "         set termguicolors
        "         " set t_8b=[48;2;%lu;%lu;%lum
        "         " set t_8f=[38;2;%lu;%lu;%lum
        "     endif
        " endif

        if (has("termguicolors"))
            set t_8b="[48;2;%lu;%lu;%lum"
            set t_8f="[38;2;%lu;%lu;%lum"
            set termguicolors
        endif

        syntax enable           " enable syntax processing
        " set t_Co=256          " enable 256 color terminal
        if (has("nvim"))
            let $NVIM_TUI_ENABLE_TRUE_COLOR=1
        endif
        set background=dark " lihgt / dark

        try
            colorscheme edge
            " colorscheme seoul256
            " colorscheme base16-default-dark
            " colorscheme base17-eighties
            " colorscheme gruvbox
            " colorscheme hybrid
            " colorscheme Tomorrow-Night-Eighties
            " colorscheme onedark
        catch
        endtry

        " " seoul 256 terminal color
        " let g:terminal_color_0  = '#4e4e4e'
        " let g:terminal_color_1  = '#d68787'
        " let g:terminal_color_2  = '#5f865f'
        " let g:terminal_color_3  = '#d8af5f'
        " let g:terminal_color_4  = '#85add4'
        " let g:terminal_color_5  = '#d7afaf'
        " let g:terminal_color_6  = '#87afaf'
        " let g:terminal_color_7  = '#d0d0d0'
        " let g:terminal_color_8  = '#626262'
        " let g:terminal_color_9  = '#d75f87'
        " let g:terminal_color_10 = '#87af87'
        " let g:terminal_color_11 = '#ffd787'
        " let g:terminal_color_12 = '#add4fb'
        " let g:terminal_color_13 = '#ffafaf'
        " let g:terminal_color_14 = '#87d7d7'
        " let g:terminal_color_15 = '#e4e4e4'
        highlight Pmenu ctermfg=187 guifg=#d7d7af ctermbg=95 guibg=#875f5f
        highlight PmenuSel ctermfg=236 guifg=#3f3f3f ctermbg=224 guibg=#ffdfdf
        " " highlight Pmenu ctermfg=252 guifg=#d9d9d9 ctermbg=238 guibg=#565656
        " " highlight PmenuSel ctermfg=236 guifg=#3f3f3f ctermbg=224 guibg=#ffdfdf

        " }}}

    " Spaces & Tabs {{{
        set tabstop=4       " number of visual spaces per TAB
        set softtabstop=4   " number of spaces in tab when editing
        set expandtab       " tabs are spaces
        set shiftwidth=4    " auto indent 4
        set cindent         " indent only for C language
        set smartindent     " smart indentation
        set copyindent      " copy the previous indentation on autoindenting
        set autoindent      " always set autoindenting on
        autocmd FileType yaml setlocal tabstop=2 softtabstop=2 shiftwidth=2
    " }}}

    " UI Config {{{
        set ruler           " show line and col
        set relativenumber  " show relative line numbers
        set number          " show absolute line numbers where your cursor is
        set numberwidth=3   " keep the line number gutter narrow
        set showcmd         " show command in bottom bar
        set cursorline      " highlight current line
        filetype indent on  " load filetype-specific index files
        set showmatch       " highlight matching [{()}]
        set title           " change the terminal's title
        set lazyredraw      " redraw only when we need to
        set noshowmode      " for echodoc to hide -- INSERT -- in command line
    " }}}

    " Searching {{{
        set incsearch       " show search matches as you type
        set hlsearch        " highlight mtches
        set ignorecase      " ignore case when searching
        set smartcase       " ignore case if search pattern is all lowercase,
                            " case-sensitive otherwise
    " }}}

    " Folding {{{
        set foldenable          " enable folding
        set foldlevelstart=10   " open most folds by default
        set foldnestmax=10      " 10 nested fold max
        set foldmethod=syntax   " fold based on syntax
        set foldlevel=1
    " }}}

" }}}



" VIM REMAPPING AND FUNCTIONS {{{

    " neovim python support {{{
        if has('nvim')
            let g:python_host_prog = system("echo -n $HOME/.virtualenvs/neovim2/bin/python")
            let g:python3_host_prog = system("echo -n $HOME/.virtualenvs/neovim3/bin/python")
        endif
    " }}}

    " leader is now comma {{{
        map , <leader>
    " }}}

    " Remove trailing whitespaces on save {{{
        fun! StripTrailingWhitespaces()
            let l = line(".")
            let c = col(".")
            %s/\s\+$//e
            call cursor(l, c)
        endfun
        autocmd FileType c,cpp,java,javascript,html,ruby,python,pandoc
            \ autocmd BufWritePre <buffer> :call StripTrailingWhitespaces()
    " }}}

    " Disable few things on file larger than 250mb {{{
        let g:LargeFile = 1024 * 1024 * 250
        augroup LargeFile
            autocmd BufReadPre * let f=getfsize(expand("<afile>")) | if f > g:LargeFile || f == -2 | call LargeFile() | endif
        augroup END

        function! LargeFile()
            " no syntax highlighting etc
            " set eventignore+=FileType
            " save memory when other file is viewed
            setlocal bufhidden=unload
            " is read-only (write with :w new_filename)
            setlocal buftype=nowrite
            " no undo possible
            setlocal undolevels=-1
            " display message
            autocmd VimEnter *  echo 'The file is larger than ' . (g:LargeFile / 1024 / 1024) . ' MB, so some options are changed (see .vimrc for details).'
        endfunction
    " }}}

    " Vim jump to the last position when reopening a file {{{
        if has("autocmd")
            au BufReadPost * if line("'\"") > 1 && line("'\"") <= line("$") | exe "normal! g'\"" | endif
        endif
    " }}}

    " work like * and g*, but do not move the cursor and always set hls {{{
        nnoremap * :let @/ = '\<'.expand('<cword>').'\>'\|set hlsearch<C-M>
        nnoremap g* :let @/ = expand('<cword>')\|set hlsearch<C-M>
    " }}}

    " visual mode pressing * or # searches for the current selection {{{
        vnoremap <silent> * :<C-U>
                    \let old_reg=getreg('"')<Bar>let old_regtype=getregtype('"')<CR>
                    \gvy/<C-R>=&ic?'\c':'\C'<CR><C-R><C-R>=substitute(
                    \escape(@", '/\.*$^~['), '\_s\+', '\\_s\\+', 'g')<CR><CR>
                    \gVzv:call setreg('"', old_reg, old_regtype)<CR>
        vnoremap <silent> # :<C-U>
                    \let old_reg=getreg('"')<Bar>let old_regtype=getregtype('"')<CR>
                    \gvy?<C-R>=&ic?'\c':'\C'<CR><C-R><C-R>=substitute(
                    \escape(@", '?\.*$^~['), '\_s\+', '\\_s\\+', 'g')<CR><CR>
                    \gVzv:call setreg('"', old_reg, old_regtype)<CR>
    " }}}

    " " Turns off vim's crazy default regex characters (very magic) {{{
    "     nnoremap / /\v
    "     vnoremap / /\v
    "     cnoremap s/ s/\v
    " " }}}

    " do not exit from visual mode when shifting {{{
        vnoremap < <gv
        vnoremap > >gv
    " }}}

    " Treat long lines as break lines {{{
        " (useful when moving around in them) but when preceded by a count, 
        " go back to normal and save movement in jumplist lager than 5 
        nnoremap <expr> j v:count ? (v:count > 5 ? "m'" . v:count : '') . 'j' : 'gj'
        nnoremap <expr> k v:count ? (v:count > 5 ? "m'" . v:count : '') . 'k' : 'gk'
    " }}}

    " turn off search highlight {{{
        nmap <leader><space> :nohlsearch<CR>
    " }}}

    " "  keep search pattern in the middle of screen {{{
    "    nnoremap n nzz
    "    nnoremap N Nzz
    " " }}}

    " Make arrow keys do something useful {{{
        nnoremap <Left> :vertical resize +2<CR>
        nnoremap <Right> :vertical resize -2<CR>
        nnoremap <Up> :resize -2<CR>
        nnoremap <Down> :resize +2<CR><Paste>
    " }}}

    " Buffer navigation {{{
        function! s:buffernavigation(cmd)
            let buf = bufnr()
            execute a:cmd
            while ( &buftype == 'terminal' 
                        \ || &filetype == 'fugitive'
                        \ || &filetype == 'dirvish') 
                        \ && bufnr() != buf
                execute a:cmd
            endwhile
        endfunction

        " Go back to previous buffer
        nmap <C-W><tab> :e#<CR>
        " buffer previous
        nnoremap [b :<c-u>call <SID>buffernavigation('bprevious')<CR>
        " buffer next
        nnoremap ]b :<c-u>call <SID>buffernavigation('bnext')<CR>
        " new empty buffer
        nnoremap <C-b> :enew<CR>
        " conform changes (Yes, No, Cancel) instead of error
        " set confirm
        " close buffer
        nnoremap <leader>bx :bp <BAR> bd #<CR>
    " }}}

    " Tab navigations {{{
        " tap previous
        nnoremap [t  :tabprevious<CR>
        " tap next
        nnoremap ]t  :tabnext<CR>
        function! OpenCurrentAsNewTab()
            let l:currentPos = getcurpos()
            tabedit %
            call setpos(".", l:currentPos)
        endfunction
        " new tap with current buffer
        nnoremap <C-t> :call OpenCurrentAsNewTab()<CR>
        " close tap
        nnoremap <leader>tx :tabclose<CR>
    " }}}

    " Vim Split navigations {{{
        nmap <C-J> <C-W><C-J>
        nmap <C-K> <C-W><C-K>
        nmap <C-L> <C-W><C-L>
        nmap <C-H> <C-W><C-H>
        set splitbelow
        set splitright
        " Vim Split command remapping like tmux
        " horizontal split
        nmap <C-W>h <C-W>s
        " vertical split (no need to remap)
        " remove split
        nmap <C-W>x <C-W>q
    " }}}

    " Sudo Save (:Wsudo command) {{{
        command! Wsudo w !sudo tee % > /dev/null
    " }}}

    " <leader>cd : switch to the directory of the current buffer {{{
        nmap <leader>cd :cd %:p:h<CR>
    " }}}

    " <leader>{y,x,p} : {yank,cut,paste} wrt the system clipboard {{{
        map <leader>y "+y
        noremap <leader>x "+x
        noremap <leader>p "+p
    " }}}

    " yanked text to osc52 {{{
        " copy to attached terminal using the yank(1) script:
        " https://github.com/sunaku/home/blob/master/bin/yank
        function! Yank(text) abort
            let escape = system('osc52', a:text)
            if v:shell_error
                echoerr escape
            endif
        endfunction

        " automatically run yank(1) whenever yanking in Vim
        function! CopyYank() abort
            call Yank(join(v:event.regcontents, "\n"))
        endfunction
        autocmd TextYankPost * call CopyYank()
    " }}}

    " Search in current visible window {{{
        command! -nargs=1 WinSearch exe '/\%>'.(line('w0')-1).'l'.<q-args>.'\%<'.(line('w$')+1).'l'
        nnoremap z/ :set scrolloff=0<CR>VHoL<Esc>:set scrolloff=1<CR>``/\%V
    " }}}

    " I am too lazy to take my hands from shift {{{
        command! WQ wq
        command! Wq wq
        command! W w
    " }}}

    " Replace a word under the curser and '.' to repeat 'n' to skip (c*) {{{
        let g:should_inject_replace_occurences = 0
        function! MoveToNext()
            if g:should_inject_replace_occurences
                call feedkeys("n")
                call repeat#set("\<Plug>ReplaceOccurences")
            endif

            let g:should_inject_replace_occurences = 0
        endfunction

        augroup auto_move_to_next
            autocmd! InsertLeave * :call MoveToNext()
        augroup END

        nmap <silent> <Plug>ReplaceOccurences :call ReplaceOccurence()<CR>
        nmap <silent> c* :let @/ = '\C\<'.expand('<cword>').'\>'<CR>
            \:set hlsearch<CR>:let g:should_inject_replace_occurences=1<CR>cgn
        vmap <silent> c* :<C-U>
            \let old_reg=getreg('"')<Bar>let old_regtype=getregtype('"')<CR>
            \gvy:let @/ = substitute(
            \escape(@", '/\.*$^~['), '\_s\+', '\\_s\\+', 'g')<CR>:set hlsearch<CR>:let g:should_inject_replace_occurences=1<CR>
            \gV:call setreg('"', old_reg, old_regtype)<CR>cgn

        function! ReplaceOccurence()
            " check if we are on top of an occurence
            let l:winview = winsaveview()
            let l:save_reg = getreg('"')
            let l:save_regmode = getregtype('"')
            let [l:lnum_cur, l:col_cur] = getpos(".")[1:2]
            normal! ygn
            let [l:lnum1, l:col1] = getpos("'[")[1:2]
            let [l:lnum2, l:col2] = getpos("']")[1:2]
            call setreg('"', l:save_reg, l:save_regmode)
            call winrestview(winview)

            " if we are on top of an occurence, replace it
            if l:lnum_cur >= l:lnum1 && l:lnum_cur <= l:lnum2 && l:col_cur >= l:col1 && l:col_cur <= l:col2
                exe "normal! cgn\<c-a>\<esc>"
            endif

            call feedkeys("n")
            call repeat#set("\<Plug>ReplaceOccurences")
        endfunction
    " }}}

    " Terminal inside of vim {{{
        " steal from https://github.com/vimlab/split-term.vim
        fun! s:openBuffer(count, vertical)
            let cmd = a:vertical ? 'vnew' : 'new'
            let cmd = a:count ? a:count . cmd : cmd
            exe cmd
        endf
        " steal https://github.com/junegunn/fzf.vim/issues/821#issuecomment-581273191
        func! s:openFloatBuffer()
            " Configuration
            let height = float2nr((&lines - 2) * 0.6)
            let row = float2nr((&lines - height) / 2)
            let width = float2nr(&columns * 0.8)
            let col = float2nr((&columns - width) / 2)
            let top = "╭" . repeat("─", width + 2) . "╮"
            let mid = "│" . repeat(" ", width + 2) . "│"
            let bot = "╰" . repeat("─", width + 2) . "╯"
            let border = [top] + repeat([mid], height) + [bot]

            " Border Window
            let border_opts = {
                        \ 'row': row - 1,
                        \ 'col': col - 2,
                        \ 'width': width + 4,
                        \ 'height': height + 2,
                        \ }
            " Terminal Window
            let opts = {
                        \ 'row': row,
                        \ 'col': col,
                        \ 'width': width,
                        \ 'height': height,
                        \ }

            if has ('nvim')
                let frame = s:create_float('Todo', border_opts)
                call nvim_buf_set_lines(frame, 0, -1, v:true, border)
                call s:create_float('Normal', opts)
            else
                let opts = extend({'is_frame': 1,}, border_opts)
                let frame = s:create_popup_window('Todo', border_opts)
                call setbufline(frame, 1, border)
                call s:create_popup_window('Normal', opts)
            endif
        endf
        fun s:create_float(hl, opts) abort
            let buf = nvim_create_buf(v:false, v:true)
            let opts = extend({'relative': 'editor', 'style': 'minimal'}, a:opts)
            let win = nvim_open_win(buf, v:true, opts)
            call setwinvar(win, '&winhighlight', 'NormalFloat:'..a:hl)
            " Close border window when terminal window close
            exe 'autocmd TermClose * ++once :bd! | call nvim_win_close('..l:win..', v:true)'
            return buf
        endfu
        fun s:create_popup_window(hl, opts) abort
            if has_key(a:opts, 'is_frame')
                let id = popup_create('', #{
                            \ line: a:opts.line,
                            \ col: a:opts.col,
                            \ minwidth: a:opts.width,
                            \ minheight: a:opts.height,
                            \ zindex: 50,
                            \ })
                call setwinvar(id, '&wincolor', a:hl)
                exe 'au BufWipeout * ++once call popup_close('..id..')'
                return winbufnr(id)
            else
                let buf = term_start(&shell, #{hidden: 1})
                call popup_create(buf, #{
                            \ line: a:opts.line,
                            \ col: a:opts.col,
                            \ minwidth: a:opts.width,
                            \ minheight: a:opts.height,
                            \ zindex: 51,
                            \ })
                exe 'au BufWipeout * ++once bw! '..buf
            endif
        endfu
        fun! s:openTerm(args, count, direction)
            let params = split(a:args)
            let direction = a:direction

            if a:direction == 3
                call s:openFloatBuffer()
            else
                call s:openBuffer(a:count, direction)
            endif

            exe 'terminal' a:args
            exe 'startinsert'
        endf
        command! -count -nargs=* TermHorizontal call s:openTerm(<q-args>, <count>, 0)
        command! -count -nargs=* TermVertical call s:openTerm(<q-args>, <count>, 1)
        command! -count -nargs=* TermFloat call s:openTerm(<q-args>, <count>, 3)
        if has('nvim-0.4') || has('patch-8.2.191')
            nnoremap <leader>R :TermFloat<CR>
        else
            nnoremap <leader>R :TermHorizontal<CR>
        endif

        tnoremap <Esc> <C-\><C-n>
        if has('nvim')
            autocmd TermOpen term://*fzf* tnoremap <buffer> <Esc> <Esc>
            autocmd TermOpen * setlocal nonumber norelativenumber
        endif
    " }}}

    " Coneallevel control {{{
        function! ToggleConcealLevel()
            if &conceallevel == 0
                setlocal conceallevel=2
            else
                setlocal conceallevel=0
            endif
        endfunction
        nnoremap <silent> yoa :call ToggleConcealLevel()<CR>
    " }}}

    " Change register {{{
        function! ChangeReg() abort
            let r = nr2char(getchar())
            if r =~# '[a-zA-Z0-9"@\-:.%#=*"~_/]'
                call feedkeys("q:ilet @" . r . " = \<C-r>\<C-r>=string(@" . r . ")\<CR>\<ESC>", 'n')
            endif
        endfunction
        nnoremap <silent> rc :call ChangeReg()<CR>
    " }}}

    " Move visual block {{{
        vnoremap J :m '>+1<CR>gv=gv
        vnoremap K :m '<-2<CR>gv=gv
    " }}}

    " Redirect the output of a Vim or external command into a scratch buffer {{{
        " https://gist.github.com/romainl/eae0a260ab9c135390c30cd370c20cd7
        function! Redir(cmd)
            for win in range(1, winnr('$'))
                if getwinvar(win, 'scratch')
                    execute win . 'windo close'
                endif
            endfor
            if a:cmd =~ '^!'
                if a:cmd =~' %'
                    let cmd = substitute(a:cmd, ' %', ' ' . expand('%:p'), '')
                else
                    let cmd = a:cmd
                endif
                let output = system(matchstr(cmd, '^!\zs.*'))
            else
                redir => output
                execute a:cmd
                redir END
            endif
            vnew
            let w:scratch = 1
            setlocal buftype=nofile bufhidden=wipe nobuflisted noswapfile
            call setline(1, split(output, "\n"))
        endfunction

        command! -nargs=1 -complete=command Redir silent call Redir(<q-args>)
        " Usage:
        " 	:Redir %w !python ..... show the full output of command ':%w !python' in a scratch window
        " 	:Redir .w !bash ....... show the full output of command ':.w !bash' in a scratch window
        " 	:Redir hi ............. show the full output of command ':hi' in a scratch window
        " 	:Redir !ls -al ........ show the full output of command ':!ls -al' in a scratch window
    " }}}

    " Add parentheses to the current line {{{
        " https://vimrcfu.com/snippet/267

        " wrap the current line in (), e.g:
        nnoremap () mMI(<esc>A)<esc>`M

        " wrap the rest of the line in ()
        nnoremap )) mMi(<esc>A)<esc>`M

        " wrap the line so far in ()
        nnoremap (( mMI(<esc>`Mla)<esc>
    " }}}

    " Change grep to rg if it exists {{{
        if executable('rg')
            set grepprg=rg\ -S\ --vimgrep
        endif
    " }}}

    " Improve grep {{{
        " https://gist.github.com/romainl/56f0c28ef953ffc157f36cc495947ab3
        function! Grep(...)
            if exists("*expandcmd")
                return system(join([&grepprg] + [expandcmd(join(a:000, ' '))], ' '))
            else
                " neovim v0.4.4 has no expandcmd()
                let l:expands = []
                for elem in a:000
                    let l:expands += [expand(elem)]
                endfor
                return system(join([&grepprg] + l:expands), ' ')
            endif
        endfunction
        command! -nargs=+ -complete=file_in_path -bar Grep  cgetexpr Grep(<f-args>)
        command! -nargs=+ -complete=file_in_path -bar LGrep lgetexpr Grep(<f-args>)
        " Open the location/quickfix window automatically if there are valid entries in the list
        augroup quickfix
            autocmd!
            autocmd QuickFixCmdPost cgetexpr cwindow
            autocmd QuickFixCmdPost lgetexpr lwindow
        augroup END
        cnoreabbrev <expr> grep (getcmdtype() ==# ':' && getcmdline() ==# 'grep') ? 'Grep' : 'grep'
        cnoreabbrev <expr> lgrep (getcmdtype() ==# ':' && getcmdline() ==# 'lgrep') ? 'LGrep' : 'lgrep'
    " }}}

    " calulate any things {{{
        nnoremap Q 0yt=A<C-r>=<C-r>"<CR><Esc>
        vnoremap Q c<C-r>=<C-r>"<CR><Esc>
    " }}}

    " yanking {{{
        " reselect the yanked region with `gb`
        nnoremap <expr> gb '`[' . strpart(getregtype(), 0, 1) . '`]'
        " paste without yanking in visual mode with `P`
        xnoremap <expr> P '"_d"'.v:register.'P'
    " }}}

    " auto marker {{{
        augroup contextswitch
            autocmd!
            autocmd BufLeave *.py           normal! mP
            autocmd BufLeave *.yaml,*.yml   normal! mY
            autocmd BufLeave *.md           normal! mM
        augroup END
    " }}}

    " {{{ copy the current file's full absolute path.
        command! CopyFilePath let @+ = expand(has('win32') ? '%:p:gs?/?\\?' : '%:p')
    " }}}

" }}}

" PLUGIN SETTING {{{

    " scrooloose/nerdcommenter {{{
        if has_key(g:plugs, 'nerdcommenter')
            " Add spaces after comment delimiters by default
            let g:NERDSpaceDelims = 1
            " Use compact syntax for prettified multi-line comments
            let g:NERDCompactSexyComs = 1
            " Align line-wise comment delimiters flush left instead of following code indentation
            let g:NERDDefaultAlign = 'left'
            " Set a language to use its alternate delimiters by default
            let g:NERDAltDelims_java = 1
            " Add your own custom formats or override the defaults
            let g:NERDCustomDelimiters = { 'c': { 'left': '/**','right': '*/' } }
            " Allow commenting and inverting empty lines (useful when commenting a region)
            let g:NERDCommentEmptyLines = 1
            " Enable trimming of trailing whitespace when uncommenting
            let g:NERDTrimTrailingWhitespace = 1
            " Enable NERDCommenterToggle to check all selected lines is commented or not 
            let g:NERDToggleCheckAllLines = 1
        endif
    " }}}

    " tpope/vim-fugitive {{{
        if has_key(g:plugs, 'vim-fugitive')
            nnoremap <leader>G :Gstatus<CR>
        endif
    " }}}

    " itchyny/lightline.vim {{{
        if has_key(g:plugs, 'lightline.vim')
            let g:lightline#bufferline#show_number = 0
            let g:lightline#bufferline#shorten_path = 1
            let g:lightline#bufferline#unicode_symbols = 2
            let g:lightline#bufferline#unnamed = '[No Name]'
            let g:lightline#gitdiff#indicator_added = "+"
            let g:lightline#gitdiff#indicator_deleted = "-"
            let g:lightline#gitdiff#indicator_modified = "!"
            let g:lightline = {}
            let g:lightline = {
                        \ 'colorscheme': 'edge',
                        \ 'active': {
                        \     'left': [
                        \           [ 'mode', 'paste' ],
                        \           [ 'cocstatus', 'currentfunction',
                        \             'readonly', 'filename', 'coc_errors', 'coc_warnings' ],
                        \     ],
                        \     'right': [
                        \           [ 'lineinfo' ],
                        \           [ 'percent' ],
                        \           [ 'fileformat', 'fileencoding', 'devicons_filetype' ]
                        \     ],
                        \ },
                        \ 'tab': {
                        \     'active': [ 'tabnum' ],
                        \     'inactive': [ 'tabnum' ],
                        \ },
                        \ 'tabline': {
                        \     'left': [ [ 'tabs', 'vim_logo', 'buffers'] ],
                        \     'right': [ [ 'gitbranch'], [ 'gitdiff' ] ],
                        \ },
                        \ 'component': {
                        \     'vim_logo': "\ue7c5",
                        \ },
                        \ 'component_function': {
                        \     'readonly': 'LightlineReadonly',
                        \     'gitbranch': 'LightlineFugitive',
                        \     'filename': 'LightlineFilename',
                        \     'fileformat': 'LightlineFileformat',
                        \     'filetype': 'LightlineFiletype',
                        \     'fileencoding': 'LightlineFileencoding',
                        \     'currentfunction': 'CocCurrentFunction',
                        \     'devicons_filetype': 'Devicons_Filetype',
                        \     'devicons_fileformat': 'Devicons_Fileformat',
                        \     'cocstatus' : 'CocStatus',
                        \ },
                        \ 'component_expand': {
                        \    'buffers': 'lightline#bufferline#buffers',
                        \    'gitdiff': 'lightline#gitdiff#get',
                        \    'coc_errors': 'LightlineCocErrors',
                        \    'coc_warnings': 'LightlineCocWarnings',
                        \ },
                        \ 'component_type': {
                        \    'buffers': 'tabsel',
                        \    'coc_errors': 'error',
                        \    'coc_warnings': 'warning',
                        \ },
                        \ }

            autocmd User CocStatusChange,CocDiagnosticChange call lightline#update()

            function! CocCurrentFunction()
                return winwidth(0) > 70 ? get(b:, 'coc_current_function', '') : ''
            endfunction
            function! Devicons_Filetype()
                return winwidth(0) > 70 ? (strlen(&filetype) ? &filetype . ' ' . WebDevIconsGetFileTypeSymbol() : 'no ft') : ''
            endfunction
            function! Devicons_Fileformat()
                return winwidth(0) > 70 ? (&fileformat . ' ' . WebDevIconsGetFileFormatSymbol()) : ''
            endfunction
            function! LightlineFileformat()
                return winwidth(0) > 70 ? &fileformat : ''
            endfunction
            function! LightlineFiletype()
                return winwidth(0) > 70 ? (&filetype !=# '' ? &filetype : 'no ft') : ''
            endfunction
            function! LightlineFileencoding()
                return winwidth(0) > 70 ? (&fenc !=# '' ? &fenc : &enc) : ''
            endfunction
            function! LightlineModified()
                return &ft =~ 'help\|vimfiler' ? '' : &modified ? '+' : &modifiable ? '' : '-'
            endfunction
            function! LightlineReadonly()
                return &ft !~? 'help\|vimfiler' && &readonly ? '' : ''
            endfunction
            function! LightlineFilename()
                return ('' != LightlineReadonly() ? LightlineReadonly() . ' ' : '') .
                            \ (&ft == 'vimfiler' ? vimfiler#get_status_string() :
                            \  &ft == 'unite' ? unite#get_status_string() :
                            \  &ft == 'vimshell' ? vimshell#get_status_string() :
                            \ '' != expand('%:t') ? expand('%:t') : '[No Name]') .
                            \ ('' != LightlineModified() ? ' ' . LightlineModified() : '')
            endfunction
            function! LightlineFugitive()
                if &ft !~? 'vimfiler' && exists('*fugitive#head')
                    if fugitive#head() !=# ''
                        return fugitive#head() .  " " . "\ue725"
                    endif
                else
                    return "\uf468"
                endif
            endfunction
            function! CocStatus() abort
                let info = get(g:, 'coc_status', '')
                if empty(info)
                    return ''
                else
                    return winwidth(0) > 100 ? (info): ''
                endif
            endfunction

            function! s:lightline_coc_diagnostic(kind, sign) abort
                let info = get(b:, 'coc_diagnostic_info', 0)
                if empty(info) || get(info, a:kind, 0) == 0
                    return ''
                endif
                if a:sign == 'error'
                    let s = 'E'
                elseif a:sign == 'warning'
                    let s = 'W'
                endif
                " try
                "     let s = g:coc_user_config['diagnostic'][a:sign . 'Sign']
                " catch
                "     let s = ''
                " endtry
                return printf('%s %d', s, info[a:kind])
            endfunction
            function! LightlineCocErrors() abort
                return s:lightline_coc_diagnostic('error', 'error')
            endfunction

            function! LightlineCocWarnings() abort
                return s:lightline_coc_diagnostic('warning', 'warning')
            endfunction
        endif
    " }}}

    " junegunn/vim-easy-align {{{
        if has_key(g:plugs, 'vim-easy-align')
            " Start interactive EasyAlign in visual mode (e.g. vipga)
            xmap ga <Plug>(EasyAlign)
            " Start interactive EasyAlign for a motion/text object (e.g. gaip)
            nmap ga <Plug>(EasyAlign)
        endif
    " }}}

    " Yggdroot/indentLine {{{
        if has_key(g:plugs, 'indentLine')
            let g:indentLine_enabled    = 1
            let g:indentLine_faster     = 1
            " let g:indentLine_setConceal = 0
            " let g:indentLine_char = '┊'
            let g:indentLine_char_list = ['|', '¦', '┆', '┊']
        endif
    " }}}

    " junegunn/goyo.vim {{{
        if has_key(g:plugs, 'goyo.vim')
            let g:hoyo_width = 120
        endif
    " }}}

    " kshenoy/vim-signature {{{
        if has_key(g:plugs, 'vim-signature')
            let g:SignatureMarkTextHLDynamic = 1
        endif
    " }}}

    " Shougo/deoplete.nvim {{{
        if has_key(g:plugs, 'deoplete.nvim')
            let g:deoplete#enable_at_startup = 1
            call deoplete#custom#option({
                        \ 'auto_complete_delay': 20,
                        \ 'auto_refresh_delay': 30,
                        \ 'skip_chars': ['(', ')', '<', '>'],
                        \ 'num_processes': 4,
                        \ 'min_pattern_length': 2,
                        \ })

            " automatically close preview window
            autocmd InsertLeave,CompleteDone * if pumvisible() == 0 | pclose | endif

            " suppress the annoying 'match x of y', 'The only match' and 'Pattern not
            " found' messages
            " set shortmess+=c

            " set completeopt+=noinsert
            " set completeopt-=preview


            " Register some default omnicomplete functions/patterns
            " to automatically trigger in deoplete {{
            " let g:deoplete#omni#functions = get(g:, 'deoplete#omni#functions', {})
            " let g:deoplete#omni#input_patterns = get(g:, 'deoplete#omni#input_patterns', {})
            "
            " let g:deoplete#omni#functions.tex = ['vimtex#complete#omnifunc']
            " let g:deoplete#omni#input_patterns.tex =
            "       \ '(?:'
            "       \ . '\\\w*'
            "       \ . ')'

            " deoplete-clang
            " if filereadable('/usr/lib/llvm-3.8/lib/libclang.so.1')
            "     let g:deoplete#sources#clang#libclang_path = '/usr/lib/llvm-3.8/lib/libclang.so.1'
            " elseif filereadable('/Library/Developer/CommandLineTools/usr/lib/libclang.dylib')
            "     let g:deoplete#sources#clang#libclang_path = '/Library/Developer/CommandLineTools/usr/lib/libclang.dylib'
            " endif
            "
            " if isdirectory('/usr/include/clang')
            "     let g:deoplete#sources#clang#clang_header = '/usr/include/clang/'
            " elseif isdirectory('/Library/Developer/CommandLineTools/usr/lib/clang/')
            "     let g:deoplete#sources#clang#clang_header = '/Library/Developer/CommandLineTools/usr/lib/clang/'
            " endif

            " <CR>: If popup menu visible, expand snippet or close popup with selection,
            "       Otherwise, just put '<CR>'
            " inoremap <silent><expr><CR> pumvisible() ?
            "     \ (neosnippet#expandable() ? neosnippet#mappings#expand_impl() : deoplete#close_popup())
            "         \ :  "\<CR>"

            " <Tab> completion:
            " 1. If popup menu is visible, select and insert next item
            " 2. Otherwise, if within a snippet, jump to next input
            " 3. Otherwise, if preceding chars are whitespace, insert tab char
            " 4. Otherwise, start manual autocomplete
            imap <silent><expr><Tab> pumvisible() ? "\<C-n>"
                \ : (neosnippet#jumpable() ? "\<Plug>(neosnippet_expand_or_jump)"
                \ : (<SID>is_whitespace() ? "\<Tab>"
                \ : deoplete#manual_complete()))

            smap <silent><expr><Tab> pumvisible() ? "\<C-n>"
                \ : (neosnippet#jumpable() ? "\<Plug>(neosnippet_expand_or_jump)"
                \ : (<SID>is_whitespace() ? "\<Tab>"
                \ : deoplete#manual_complete()))

            inoremap <expr><S-Tab> pumvisible() ? "\<C-p>" : "\<C-h>"

            function! s:is_whitespace()
                let col = col('.') - 1
                return ! col || getline('.')[col - 1] =~? '\s'
            endfunction

            function! s:is_back_space()
                let col = col('.') - 1
                return ! col || getline('.')[col - 1] =~ s
            endfunction
        endif
    " }}}

    " sirver/ultisnips {{{
        if has_key(g:plugs, 'ultisnips')
            let g:UltiSnipsExpandTrigger="<c-j>"
            let g:UltiSnipsJumpForwardTrigger="<c-j>"
            let g:UltiSnipsJumpBackwardTrigger="<c-k>"
            let g:UltiSnipsEditSplit="vertical"
            let g:UltiSnipsSnippetDirectories = ['UltiSnips', 'snips']
        endif
    " }}}

    " neoclide/coc.nvim {{{
        if has_key(g:plugs, 'coc.nvim')
            let g:coc_global_extensions = [
                        \ 'coc-json',
                        \ 'coc-snippets',
                        \ 'coc-tsserver',
                        \ 'coc-html',
                        \ 'coc-css',
                        \ 'coc-emoji',
                        \ 'coc-yaml',
                        \ 'coc-vimtex',
                        \ 'coc-python',
                        \ 'coc-go',
                        \ 'coc-sh'
                        \ ]

            " automatically change python interpreter path
            " autocmd FileType python !~/.config/nvim/update_coc_settings.sh
            if executable('python')
                " need to clean up
                if has('nvim')
                    call coc#config('python', {
                                \ 'pythonPath': split(execute('!which python'), '\n')[-1]
                                \ })
                else
                    call coc#config('python', {
                                \ 'pythonPath': system('!which python')
                                \ })
                endif
            endif

            " add ccls languageserver
            if executable('ccls')
                call coc#config('languageserver.ccls', {
                            \ 'command': 'ccls',
                            \ 'filetypes': ['c', 'cpp', 'objc', 'objcpp'],
                            \ 'rootPatterns': ['.ccls', 'compile_commands.json', '.vim/', '.git/', '.hg/'],
                            \ 'initializationOptions': {
                                \ 'cache': {
                                \ 'directory': '/tmp/ccls'
                                \ }}})
            endif

            " add user defined snippets
            call coc#config('snippets.userSnippetsDirectory', split(system('dirname ' . $MYVIMRC))[-1] . '/snips')

            " Use <C-j> for jump to next placeholder, it's default of coc.nvim
            let g:coc_snippet_next = '<c-j>'

            " Use <C-k> for jump to previous placeholder, it's default of coc.nvim
            let g:coc_snippet_prev = '<c-k>'

            " Use tab for trigger completion with characters ahead and navigate.
            " NOTE: Use command ':verbose imap <tab>' to make sure tab is not mapped by
            " other plugin before putting this into your config.
            inoremap <silent><expr> <TAB>
                  \ pumvisible() ? "\<C-n>" :
                  \ <SID>check_back_space() ? "\<TAB>" :
                  \ coc#refresh()
            inoremap <expr><S-TAB> pumvisible() ? "\<C-p>" : "\<C-h>"

            function! s:check_back_space() abort
               let col = col('.') - 1
               return !col || getline('.')[col - 1]  =~# '\s'
            endfunction

            " Use <c-space> to trigger completion.
            if has('nvim')
                inoremap <silent><expr> <c-space> coc#refresh()
            else
                inoremap <silent><expr> <c-@> coc#refresh()
            endif

            " Use <cr> to confirm completion, `<C-g>u` means break undo chain at current
            " position. Coc only does snippet and additional edit on confirm.
            " <cr> could be remapped by other vim plugin, try `:verbose imap <CR>`.
            if exists('*complete_info')
                inoremap <expr> <cr> complete_info()["selected"] != "-1" ? "\<C-y>" : "\<C-g>u\<CR>"
            else
                inoremap <expr> <cr> pumvisible() ? "\<C-y>" : "\<C-g>u\<CR>"
            endif

            " Use `[d` and `]d` to navigate diagnostics
            " Use `:CocDiagnostics` to get all diagnostics of current buffer in location list.
            nmap <silent> [d <Plug>(coc-diagnostic-prev)
            nmap <silent> ]d <Plug>(coc-diagnostic-next)

            " GoTo code navigation.
            nmap <silent> gd <Plug>(coc-definition)
            nmap <silent> gy <Plug>(coc-type-definition)
            nmap <silent> gi <Plug>(coc-implementation)
            nmap <silent> gr <Plug>(coc-references)

            " Use K to show documentation in preview window.
            nnoremap <silent> K :call <SID>show_documentation()<CR>

            function! s:show_documentation()
              if (index(['vim','help'], &filetype) >= 0)
                execute 'h '.expand('<cword>')
              else
                call CocAction('doHover')
              endif
            endfunction

            " Highlight the symbol and its references when holding the cursor.
            autocmd CursorHold * silent call CocActionAsync('highlight')

            " Symbol renaming.
            nmap <leader>rn <Plug>(coc-rename)

            " Formatting selected code.
            xmap <leader>f  <Plug>(coc-format-selected)
            nmap <leader>f  <Plug>(coc-format-selected)

            augroup mygroup
              autocmd!
              " Setup formatexpr specified filetype(s).
              autocmd FileType typescript,json setl formatexpr=CocAction('formatSelected')
              " Update signature help on jump placeholder.
              autocmd User CocJumpPlaceholder call CocActionAsync('showSignatureHelp')
            augroup end

            " Applying codeAction to the selected region.
            " Example: `<leader>aap` for current paragraph
            xmap <leader>a  <Plug>(coc-codeaction-selected)
            nmap <leader>a  <Plug>(coc-codeaction-selected)

            " Remap keys for applying codeAction to the current buffer.
            nmap <leader>ac  <Plug>(coc-codeaction)
            " Apply AutoFix to problem on the current line.
            nmap <leader>qf  <Plug>(coc-fix-current)

            " Map function and class text objects
            " NOTE: Requires 'textDocument.documentSymbol' support from the language server.
            xmap if <Plug>(coc-funcobj-i)
            omap if <Plug>(coc-funcobj-i)
            xmap af <Plug>(coc-funcobj-a)
            omap af <Plug>(coc-funcobj-a)
            xmap ic <Plug>(coc-classobj-i)
            omap ic <Plug>(coc-classobj-i)
            xmap ac <Plug>(coc-classobj-a)
            omap ac <Plug>(coc-classobj-a)

            " Use CTRL-S for selections ranges.
            " Requires 'textDocument/selectionRange' support of LS, ex: coc-tsserver
            nmap <silent> <C-s> <Plug>(coc-range-select)
            xmap <silent> <C-s> <Plug>(coc-range-select)

            " Add `:Format` command to format current buffer.
            command! -nargs=0 Format :call CocAction('format')

            " Add `:Fold` command to fold current buffer.
            command! -nargs=? Fold :call     CocAction('fold', <f-args>)

            " Add `:OR` command for organize imports of the current buffer.
            command! -nargs=0 OR   :call     CocAction('runCommand', 'editor.action.organizeImport')

            " Add (Neo)Vim's native statusline support.
            " NOTE: Please see `:h coc-status` for integrations with external plugins that
            " provide custom statusline: lightline.vim, vim-airline.
            " set statusline^=%{coc#status()}%{get(b:,'coc_current_function','')}
        endif
    " }}}

    " mhinz/vim-startify {{{
        if has_key(g:plugs, 'vim-startify')
            nnoremap <leader>S :Startify<CR>
            let g:startify_bookmarks = [
                        \ { 'a': $MYVIMRC },
                        \ { 's': fnamemodify(fnamemodify($MYVIMRC, ':h'), ':h') . '/tmux/tmux.conf' },
                        \ { 'z': fnamemodify(fnamemodify($MYVIMRC, ':h'), ':h') . '/zsh/zshrc' },
                        \ { 'x': fnamemodify(fnamemodify($MYVIMRC, ':h'), ':h') . '/zsh/zpreztorc' },
                        \ { 'q': fnamemodify(fnamemodify($MYVIMRC, ':h'), ':h') . '/config/fish/config.fish' },
                        \]
            let g:startify_change_to_dir = 0
        endif
    " }}}

    " junegunn/fzf.vim {{{
        if has_key(g:plugs, 'fzf.vim')
            nnoremap <leader>F :Files<CR>
            nnoremap <leader>B :Buffers<CR>
            nnoremap <leader>H :History<CR>
            nnoremap <leader>C :Commits<CR>
            nnoremap <leader>L :BLines<CR>
            nnoremap <leader>P :ProjectFiles<CR>

            if has('nvim-0.4') || has('patch-8.2.191')
                let g:fzf_layout = { 'window': { 'width': 0.9, 'height': 0.6, 'highlight': 'Todo' } }
            endif

            " Search project root
            function! s:find_git_root()
                return system('git rev-parse --show-toplevel 2> /dev/null')[:-2]
            endfunction
            command! ProjectFiles execute 'Files' s:find_git_root()

            " Customize fzf colors to match your color scheme
            let g:fzf_colors =
                        \ {
                        \ 'fg':      ['fg', 'Normal'],
                        \ 'bg':      ['bg', 'Normal'],
                        \ 'hl':      ['fg', 'Comment'],
                        \ 'fg+':     ['fg', 'CursorLine', 'CursorColumn', 'Normal'],
                        \ 'bg+':     ['bg', 'CursorLine', 'CursorColumn'],
                        \ 'hl+':     ['fg', 'Statement'],
                        \ 'info':    ['fg', 'PreProc'],
                        \ 'border':  ['fg', 'Ignore'],
                        \ 'prompt':  ['fg', 'Conditional'],
                        \ 'pointer': ['fg', 'Exception'],
                        \ 'marker':  ['fg', 'Keyword'],
                        \ 'spinner': ['fg', 'Label'],
                        \ 'header':  ['fg', 'Comment'] }

            " Likewise, Files command with preview window
            command! -bang -nargs=? -complete=dir Files
                        \ call fzf#vim#files(<q-args>, fzf#vim#with_preview(), <bang>0)

            " Rg: start fzf
            " Rg!: start fzf with preview window
            command! -bang -nargs=* Rg
              \ call fzf#vim#grep(
              \   'rg --column --line-number --no-heading --color=always --smart-case '.shellescape(<q-args>), 1,
              \   <bang>0 ? fzf#vim#with_preview('up:60%')
              \           : fzf#vim#with_preview('right:50%:hidden', '?'),
              \   <bang>0)
        endif
    " }}}

    " numirias/semshi {{{
        if has_key(g:plugs, 'semshi')
            function! CustomSemshiHighlights()
                hi semshiLocal           ctermfg=209 guifg=#ff875f
                hi semshiGlobal          ctermfg=214 guifg=#ffaf00
                hi semshiImported        ctermfg=214 guifg=#ffaf00 cterm=bold gui=bold
                hi semshiParameter       ctermfg=75  guifg=#5fafff
                hi semshiParameterUnused ctermfg=117 guifg=#87d7ff cterm=underline gui=underline
                hi semshiFree            ctermfg=218 guifg=#ffafd7
                " hi semshiBuiltin         ctermfg=207 guifg=#ff5fff
                " hi semshiAttribute       ctermfg=49  guifg=#00ffaf
                hi semshiAttribute       ctermfg=49  guifg=#02c085
                hi semshiSelf            ctermfg=249 guifg=#b2b2b2
                hi semshiUnresolved      ctermfg=226 guifg=#ffff00 cterm=underline gui=underline
                hi semshiSelected        ctermfg=231 guifg=#ffffff ctermbg=161 guibg=#d7005f

                hi! def link  semshiBuiltin  Structure
            endfunction
            autocmd FileType python call CustomSemshiHighlights()
            let g:semshi#error_sign = 0
        endif
    " }}}

    " plasticboy/vim-markdown {{{
        if has_key(g:plugs, 'vim-markdown')
            let g:vim_markdown_math = 1
        endif
    " }}}

    " machakann/vim-sandwich {{{
        if has_key(g:plugs, 'vim-sandwich')
            " vim-surround mapping
            runtime macros/sandwich/keymap/surround.vim
            " if you have not copied default recipes
            let g:sandwich#recipes = deepcopy(g:sandwich#default_recipes)

            " add spaces inside braket
            let g:sandwich#recipes += [
                  \   {'buns': ['{ ', ' }'], 'nesting': 1, 'match_syntax': 1, 'kind': ['add', 'replace'], 'action': ['add'], 'input': ['{']},
                  \   {'buns': ['[ ', ' ]'], 'nesting': 1, 'match_syntax': 1, 'kind': ['add', 'replace'], 'action': ['add'], 'input': ['[']},
                  \   {'buns': ['( ', ' )'], 'nesting': 1, 'match_syntax': 1, 'kind': ['add', 'replace'], 'action': ['add'], 'input': ['(']},
                  \   {'buns': ['{\s*', '\s*}'],   'nesting': 1, 'regex': 1, 'match_syntax': 1, 'kind': ['delete', 'replace', 'textobj'], 'action': ['delete'], 'input': ['{']},
                  \   {'buns': ['\[\s*', '\s*\]'], 'nesting': 1, 'regex': 1, 'match_syntax': 1, 'kind': ['delete', 'replace', 'textobj'], 'action': ['delete'], 'input': ['[']},
                  \   {'buns': ['(\s*', '\s*)'],   'nesting': 1, 'regex': 1, 'match_syntax': 1, 'kind': ['delete', 'replace', 'textobj'], 'action': ['delete'], 'input': ['(']},
                  \ ]
        endif
    " }}}

    " dhruvasagar/vim-table-mode {{{
        if has_key(g:plugs, 'vim-table-mode')
            let g:table_mode_corner='|'
            " let g:table_mode_corner_corner='+'
            " let g:table_mode_header_fillchar='='
        endif
    " }}}

    " unblevable/quick-scope {{{
        if has_key(g:plugs, 'quick-scope')
            let g:qs_highlight_on_keys = ['f', 'F', 't', 'T']
            highlight QuickScopePrimary guifg='#afff5f' gui=underline ctermfg=155 cterm=underline
            highlight QuickScopeSecondary guifg='#5fffff' gui=underline ctermfg=81 cterm=underline
            " augroup qs_colors
            "     autocmd!
            "     autocmd ColorScheme * highlight QuickScopePrimary guifg='#afff5f' gui=underline ctermfg=155 cterm=underline
            "     autocmd ColorScheme * highlight QuickScopeSecondary guifg='#5fffff' gui=underline ctermfg=81 cterm=underline
            " augroup END
        endif
    " }}}

    " RRethy/vim-illuminate {{{
        if has_key(g:plugs, 'vim-illuminate')
            hi illuminatedWord        ctermfg=231 guifg=#ffffff ctermbg=161 guibg=#d7005f
            let g:Illuminate_ftblacklist = ['python', 'tagbar']
            let g:Illuminate_delay = 250
        endif
    " }}}

    " chrisbra/csv.vim {{{
        if has_key(g:plugs, 'csv.vim')
            let g:csv_delim_test = ',;|'
        endif
    " }}}

    " jiangmiao/auto-pairs {{{
        if has_key(g:plugs, 'auto-pairs')
            let g:AutoPairsFlyMode = 0
        endif
    " }}}

    " justinmk/vim-dirvish {{{
        if has_key(g:plugs, 'vim-dirvish')
            let g:dirvish_mode = ':sort ,^.*[\/],'

            augroup dirvish_config
                autocmd!

                " Map `gr` to reload.
                autocmd FileType dirvish nnoremap <silent><buffer>
                            \ gr :<C-U>Dirvish %<CR>

                " Map `gh` to hide dot-prefixed files. Press `R` or `gr` to "toggle" (reload).
                autocmd FileType dirvish nnoremap <silent><buffer>
                            \ gh :silent keeppatterns g@\v/\.[^\/]+/?$@d _<cr>:setl cole=3<cr>

                " Map ~ to go ${HOME} directory
                autocmd FileType dirvish nnoremap <silent><buffer>
                            \ g~ :<C-U>Dirvish ~<CR>
            augroup END
        endif
    " }}}

    " christoomey/vim-tmux-navigator {{{
        if has_key(g:plugs, 'vim-tmux-navigator')
            let g:tmux_navigator_no_mappings = 1

            nnoremap <silent> <C-h> :TmuxNavigateLeft<cr>
            nnoremap <silent> <C-j> :TmuxNavigateDown<cr>
            nnoremap <silent> <C-k> :TmuxNavigateUp<cr>
            nnoremap <silent> <C-l> :TmuxNavigateRight<cr>
            nnoremap <silent> <C-\> :TmuxNavigatePrevious<cr>
            " Disable tmux navigator when zooming the Vim pane
            let g:tmux_navigator_disable_when_zoomed = 1
        endif
    " }}}

    " liuchengxu/vim-which-key {{{
        if has_key(g:plugs, 'vim-which-key')
            nnoremap <silent> <leader>      :<c-u>WhichKey '\'<CR>
        endif
    " }}}

    " TaDaa/vimade {{{
        if has_key(g:plugs, 'vimade')
            let g:vimade = {
                        \ 'normalid': '',
                        \ 'normalncid': '',
                        \ 'basefg': '',
                        \ 'basebg': '',
                        \ 'fadelevel': 0.6,
                        \ 'colbufsize': 1,
                        \ 'rowbufsize': 0,
                        \ 'checkinterval': 100,
                        \ 'usecursorhold': 0,
                        \ 'detecttermcolors': 0,
                        \ 'enablescroll': 0,
                        \ 'fadepriority': 10,
                        \ 'groupdiff': 1,
                        \ 'groupscrollbind': 0,
                        \ 'enablefocusfading': 1,
                        \ }
        endif
    " }}}

    " tpope/vim-unimpaired {{{
        if has_key(g:plugs, 'vim-unimpaired')
            let g:nremap = {"[t": "", "]t": "", "[T": "", "]T": ""}
        endif
    " }}}

    " jpalardy/vim-slime {{{
        if has_key(g:plugs, 'vim-slime')
            let g:slime_target = "tmux"
            let g:slime_default_config = {"socket_name": "default", "target_pane": "{right-of}"}
        endif
    " }}}

    " lervag/vimtex {{{
        if has_key(g:plugs, 'vimtex')
            let g:tex_flavor='latex'
            let g:vimtex_view_method='zathura'
            let g:vimtex_quickfix_mode=0
            let g:tex_conceal='abdmg'
        endif
    " }}}

    " iamcco/markdown-preview.nvim {{{
        if has_key(g:plugs, 'markdown-preview.nvim')
            let g:mkdp_open_to_the_world = 1
            let g:mkdp_port = '40059'
        endif
    " }}}

    " liuchengxu/vista.vim {{{
        if has_key(g:plugs, 'vista.vim')
            let g:vista_icon_indent = ["▸ ", ""]

            let g:vista#renderer#enable_icon = 1
            let g:vista#renderer#icons = {
            \   "function": "\uf794",
            \   "variable": "\uf71b",
            \  }

            let g:vista_default_executive = 'ctags'

            let g:vista_executive_for = {
                        \ 'sh': 'coc',
                        \ 'python': 'coc',
                        \ 'yaml': 'coc',
                        \ 'tex': 'coc',
                        \ }

            nmap <Leader>T :Vista!!<CR>
        endif
    " }}}

    " lambdalisue/suda.vim {{{
        if has_key(g:plugs, 'sudo.vim')
            let g:suda_smart_edit = 1
        endif
    " }}}

    " RRethy/vim-hexokinase {{{
        if has_key(g:plugs, 'vim-hexokinase')
            let g:Hexokinase_highlighters = [ 'backgroundfull' ]
            let g:Hexokinase_ftEnabled = ['css', 'html', 'javascript', 'vim']
        endif
    " }}}

" }}}
