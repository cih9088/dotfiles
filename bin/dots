#!/usr/bin/env bash

set -eu

_DIR="$(cd "$(dirname $(readlink -f "${BASH_SOURCE[0]}"))" >/dev/null && pwd)"

DOTS_ROOT="${_DIR}/.."
_SCRIPT_DIR="${DOTS_ROOT}/script"

. "${_SCRIPT_DIR}/helpers/functions.sh"

DOTS_COMMAND=${DOTS_COMMAND:-skip}
DOTS_TARGETS=${DOTS_TARGETS:-skip}
DOTS_MODE=${DOTS_MODE:-}
DOTS_VERSION=${DOTS_VERSION:-}
DOTS_YES=${DOTS_YES:-}
DOTS_SKIP_DEPENDENCIES=${DOTS_SKIP_DEPENDENCIES:-}

VERBOSE=${VERBOSE:-false}
CONFIG=${CONFIG:-}
GH_ACCESS=${GH_ACCESS:-}
PREFIX=${PREFIX:-$HOME/.local}

PKG_APPS=(
  "zsh"           "z shell"
  "fish"          "fish shell"
  "prezto"        "framework for zsh"
  "neovim"        "text editor"
  "tmux"          "terminal multiplexer"
  "tpm"           "tmux plugin manager"
  "wget"          "non-interactive network downloader"
  "tree"          "list contents of directories in an tree-like format"
  "fd"            "find entries in the filesystem"
  "rg"            "recursively search"
  "thefuck"       "command corrector"
  "tldr"          "too long didnt read"
  "bash-snippets" "bash utils"
  "up"            "tool for writing linux pipeline"
  "jq"            "json parser"
  "sox"           "sound exchange"
  "tcpdump"       "dump traffic on a network"
  "pyenv"         "python version maanger"
  "goenv"         "golang version manager"
  "asdf"          "runtime version manager"
)

PKG_DOTS=(
  "bins"             "custom scripts and commands"
  "configs"          "custom configs"
  "tmux-plugins"     "tmux plugins"
  "neovim-plugins"   "neovim plugins"
  "neovim-providers" "neovim providers"
)

PKG_LIBS=(
  "terminfo"   "terminal database"
  "pkg-config" "package metainformaation"
  "help2man"   "simple man page generator"
  "patch"      "diff file applier"
  "ncurses"    "ncurses"
  "readline"   "readline"
  "gettext"    "gettext"
  "cmake"      "cmake"
  "zlib"       "zlib"
  "bzip2"      "bzip"
  "unzip"      "unzip"
  "gzip"       "gzip"
  "xz"         "xz"
  "sqlite3"    "sqlite3"
  "libffi"     "libffi"
  "openssl"    "oepnssl"
  "autotools"  "auottools"
  "gnutls"     "gnutls"
  "gnupg"      "gnupg"
  "openldap"   "openldap"
  # "tcl"        "tcl"
  # "tk"         "tk"
  # "libx11"     "libx11"
)

PKG_ENVS=(
  "python"                 "python"
  "python-env"             "python environments"
  "python-env--virtualenv" "virtual environment"
  "python-env--black"      "python formatter"
  "python-env--isort"      "impoort formatter"
  "python-env--flake8"     "python linter"
  "python-env--debugpy"    "debug adapter protocol for python"
  "golang"                 "golang"
  "rust"                   "rust"
  "nodejs"                 "nodejs"
  "nodejs-env"             "nodejs environments"
  "lua"                    "lua"
  "lua-env"                "lua environments"
  "lua-env--stylua"        "lua formatter"
  "sh-env"                 "shell environments"
  "sh-env--shellcheck"     "shell linter"
  "sh-env--shfmt"          "shell formatter"
)


_PKGS=( "${PKG_APPS[@]}" "${PKG_DOTS[@]}" "${PKG_LIBS[@]}" "${DOTILES_ENVS[@]}")
PKGS=()
idx=0
while [ $idx -lt ${#_PKGS[@]} ]; do
  PKGS+=("${_PKGS[$idx]}")
  idx=$(( $idx + 2 ))
done
unset _PKGS


usage() {
  LESS=-FEXR less <<HELP

${BOLD}${RED}SYNOPSIS${NC}
    ${BOLD}${RED}$(basename "$0")${NC} ${BOLD}${GREEN}COMMAND${NC} [${BOLD}${RED}-yvs${NC}] \
[${BOLD}${RED}-m ${GREEN}mode${NC}] [${BOLD}${RED}-c ${GREEN}config${NC}] \
[${BOLD}${RED}-t ${GREEN}version${NC}] \
${BOLD}${GREEN}target${NC}...


${BOLD}${RED}DESCRIPTION${NC}
    dotfile management tool


${BOLD}${RED}COMMAND${NC}
    ${BOLD}${RED}list, l${NC}
        List available libraries, applications and environments

    ${BOLD}${RED}test-prerequisites${NC}
        Test prerequisites

    ${BOLD}${RED}install, i${NC} ${BOLD}${GREEN}target${NC}
        Install ${BOLD}${GREEN}target${NC}

    ${BOLD}${RED}update, u${NC} ${BOLD}${GREEN}target${NC}
        Update ${BOLD}${GREEN}target${NC}

    ${BOLD}${RED}remove, r${NC} ${BOLD}${GREEN}target${NC}
        Remove ${BOLD}${GREEN}target${NC}

    ${BOLD}${RED}change-default-shell${NC}
        Change default shell to zsh/fish


${BOLD}${RED}OPTIONS${NC}
    ${BOLD}${RED}-m, --mode${NC} ${BOLD}${GREEN}mode${NC}
        Specify mode for ${BOLD}${GREEN}target${NC} and do not prompt for it.

        ${BOLD}local${NC}   run without sudo
        ${BOLD}system${NC}  run with sudo

    ${BOLD}${RED}-t, --version${NC} ${BOLD}${GREEN}version_to_install${NC}
        Specify a version to install. This enables ${BOLD}${RED}--skip-dependencies${NC} as well.

    ${BOLD}${RED}-y, --yes${NC}

    ${BOLD}${RED}-v, --verbose${NC}

    ${BOLD}${RED}-s, --skip-dependencies${NC}

    ${BOLD}${RED}-h, --help${NC}
        Show this help message

HELP
}

completion_zsh() {
  cat <<EOF
PKG_DOTS=($(printf " %q" "${PKG_DOTS[@]}"))
PKG_APPS=($(printf " %q" "${PKG_APPS[@]}"))
PKG_ENVS=($(printf " %q" "${PKG_ENVS[@]}"))
PKG_LIBS=($(printf " %q" "${PKG_LIBS[@]}"))

to_alternative() {
  local ARR=("\$@")
  local start_idx=1 #zsh starts array from index of 1

  out="(("
  idx=\$start_idx
  while [ \$idx -lt \${#ARR[@]} ]; do
    cmd=\${ARR[\$idx]}
    desc=\${ARR[\$((\$idx + 1))]}
    out="\$out\$cmd\:\"\$desc\" "
    idx=\$(( \$idx + 2 ))
  done
  out="\$out))"
  echo "\$out"
}

packages() {
  _alternative 'dotfiles:dotfiles:'"\$(to_alternative "\${PKG_DOTS[@]}")"
  _alternative 'applications:applications:'"\$(to_alternative "\${PKG_APPS[@]}")"
  _alternative 'envs:environments:'"\$(to_alternative "\${PKG_ENVS[@]}")"
  _alternative 'libs:libraries:'"\$(to_alternative "\${PKG_LIBS[@]}")"
}

options() {
  local command="\$1"
  local -a options

  options=(
    {-y,--yes}'[yes]'
    {-v,--verbose}'[verbose]'
    {-c,--config}'[yaml configuration file]:filename:_files -g \*.\(yaml\|yml\)'
    {-m,--mode}'[mode to manage targets]:mode:(system local)'
  )

  if [[ \$command == "install" || \$command == "update" ]]; then
    options+=(
      {-s,--skip-dependencies}'[skip dependencies for local mode]'
      {-t,--version}'[specify version to install or update]:version:'
    )
  fi

  _arguments -s -w "\$options[@]"
}

_dots() {
  local state line

  _arguments \
    {-h,--help}'[show help message]: :->done' \
    '1:command:->commands' \
    '*::arg:->args'

  case "\$state" in
    done)
      ;;
    commands)
      local commands; commands=(
        'install: install targets'
        'update: update targets'
        'remove: remove targets'
        'list: list targets'
        'test-prerequisites: test prerequisites'
        'change-default-shell: change default shell'
        'completion: auto completion'
      )
      _describe -t commands 'command' commands
      ;;
    args)
      case "\$line[1]" in
        completion)
          if [ \$#line[@] -le 2 ]; then
            local -a _shells
            _shells=('zsh')
            _describe 'shell' _shells
          fi
          ;;
        install)
          options "install"
          _alternative 'specials:special:(prerequisites)'
          packages
          ;;
        update)
          options "update"
          packages
          ;;
        remove)
          options "remove"
          packages
          ;;
        *)
          ;;
      esac
      ;;
  esac
}

compdef _dots dots
EOF
}

show_list() {
    cat <<EOF

Available list to install

- ${BOLD}${RED}Dots${NC}: ${PKG_DOTS[@]}
- ${BOLD}${RED}Apps${NC}: ${PKG_APPS[@]}
- ${BOLD}${RED}Envs${NC}: ${PKG_ENVS[@]}
- ${BOLD}${RED}Libs${NC}: ${PKG_LIBS[@]}

EOF
}


make_wrapper() {
  pushd "${DOTS_ROOT}" >/dev/null 2>&1 || exit $?
  make "$@"
  popd >/dev/null 2>&1 || exit $?
}



POSITIONAL_ARGS=()
while [[ $# -gt 0 ]]; do
  # make it also '=' separated arguments
  [[ $1 == --*=* ]] && set -- "${1%%=*}" "${1#*=}" "${@:2}"
  key="$1"

  if [[ $key != --* ]] && [[ $key == -* ]]; then
    key=${key/-/}
    tmp=()
    while read -N 1 c; do tmp+=(-$c); done <<< "$key"
    unset tmp[${#tmp[@]}-1]
    key=${tmp[0]}
    if [ ${#tmp[@]} -gt 0 ]; then
      unset tmp[0]
      set -- "$@" ${tmp[@]}
    fi
  fi

  case $key in
    -m | --mode)
      DOTS_MODE="$2"
      if [[ "local system"  != *"${DOTS_MODE}"* ]]; then
        log_error "mode must be either 'local' or 'system'"
        exit 1
      fi
      shift; shift
      ;;
    -y | --yes)
      DOTS_YES=true
      shift
      ;;
    -c | --config)
      CONFIG="$2"
      shift; shift
      ;;
    -t | --version)
      DOTS_VERSION="$2"
      DOTS_SKIP_DEPENDENCIES=true
      shift; shift
      ;;
    -v | --verbose)
      VERBOSE=true
      shift
      ;;
    -s|--skip-dependencies)
      DOTS_SKIP_DEPENDENCIES=true
      shift
      ;;
    -h | --help)
      usage
      exit 0
      ;;
    -* | --*)
      log_error "Unknown option $1"
      exit 1
      ;;
    *)
      POSITIONAL_ARGS+=("$1")
      shift
      ;;
  esac
done

set -- "${POSITIONAL_ARGS[@]}" # restore positional parameters

if [ $# -eq 0 ]; then
  log_error "Command is not provided"
  exit 1
fi
DOTS_COMMAND="${1}"
shift

# alias
[ "$DOTS_COMMAND" == "l" ] && DOTS_COMMAND=list
[ "$DOTS_COMMAND" == "i" ] && DOTS_COMMAND=install
[ "$DOTS_COMMAND" == "r" ] && DOTS_COMMAND=remove
[ "$DOTS_COMMAND" == "u" ] && DOTS_COMMAND=update


case $DOTS_COMMAND in
  list)
    show_list
    exit 0
    ;;
  completion)
    _shell="${1:-}"
    [ "$_shell" = "zsh" ] && completion_zsh && exit 0
    log_error "$_shell is not a valid option."
    exit 1
    ;;
  test-prerequisites)
    make_wrapper prerequisitesTest
    exit 0
    ;;
  change-default-shell)
    make_wrapper changeDefaultShell
    exit 0
    ;;
  install|remove|update)
    ;;
  *)
    log_error "Unknown command $DOTS_COMMAND"
    exit 1
    ;;
esac

# parse config
if [ -n "${CONFIG}" ]; then
  if [ "$#" -gt 0 ]; then
    log_error "target should not be specified if config is given."
    exit 1
  fi
  if [ ! -f "${CONFIG}" ]; then
    log_error "$CONFIG not found."
    exit 1
  fi
  CONFIG=$(readlink -f $CONFIG)
  eval $(${_SCRIPT_DIR}/helpers/parser_yaml ${CONFIG} "CONFIG_")
  DOTS_TARGETS=("${CONFIG_TARGETS[@]}")
else
  DOTS_TARGETS=($@)
fi


if [ ${#DOTS_TARGETS[@]} -eq 0 ]; then
  log_error "Please provide targets."
  exit 1
fi

for i in "${!DOTS_TARGETS[@]}"; do
  DOTS_TARGET=${DOTS_TARGETS[i]}

  if [[ "${PKGS[@]}" != *"${DOTS_TARGET}"* ]]; then
    log_error "Invalid target '$DOTS_TARGET' to ${DOTS_COMMAND}"
    exit 1
  fi
done
DOTS_TARGET="${DOTS_TARGETS[*]}"

export DOTS_COMMAND
export DOTS_TARGET
export DOTS_MODE
export DOTS_VERSION
export DOTS_YES
export DOTS_SKIP_DEPENDENCIES

export VERBOSE
export CONFIG
export GH_ACCESS
export PREFIX


make_wrapper "${DOTS_TARGETS[@]}"
